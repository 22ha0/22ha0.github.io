
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>机器学习实战-第三章-分类 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    <meta name="description" content="Chapter 3 – Classification
This notebook contains all the sample code and solutions to the exercise,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/dog.jpg"> 
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

    
    <script>var musiclist = ""</script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">

    
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>

    
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/dog.jpg" alt="" data-url="http://example.com">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">机器学习实战-第三章-分类</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('/img/cover.jpg') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="javascript:;"><b>「 </b>Article<b> 」</b></a>
                
                October 13, 2021
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/" title="机器学习实战-第三章-分类" class="">机器学习实战-第三章-分类</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    32k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    29 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/" rel="tag">机器学习实战</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <p><strong>Chapter 3 – Classification</strong></p>
<p><em>This notebook contains all the sample code and solutions to the exercises in chapter 3.</em></p>
<h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><p>First, let’s import a few common modules, ensure MatplotLib plots figures inline and prepare a function to save the figures. We also check that Python 3.5 or later is installed (although Python 2.x may work, it is deprecated so we strongly recommend you use Python 3 instead), as well as Scikit-Learn ≥0.20.</p>
<pre><code class="python"># Python ≥3.5 is required
import sys
assert sys.version_info &gt;= (3, 5)

# Is this notebook running on Colab or Kaggle?
IS_COLAB = &quot;google.colab&quot; in sys.modules
IS_KAGGLE = &quot;kaggle_secrets&quot; in sys.modules

# Scikit-Learn ≥0.20 is required
import sklearn
assert sklearn.__version__ &gt;= &quot;0.20&quot;

# Common imports
import numpy as np
import os

# to make this notebook&#39;s output stable across runs
np.random.seed(42)

# To plot pretty figures
%matplotlib inline
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rc(&#39;axes&#39;, labelsize=14)
mpl.rc(&#39;xtick&#39;, labelsize=12)
mpl.rc(&#39;ytick&#39;, labelsize=12)

# Where to save the figures
PROJECT_ROOT_DIR = &quot;.&quot;
CHAPTER_ID = &quot;classification&quot;
IMAGES_PATH = os.path.join(PROJECT_ROOT_DIR, &quot;images&quot;, CHAPTER_ID)
os.makedirs(IMAGES_PATH, exist_ok=True)

def save_fig(fig_id, tight_layout=True, fig_extension=&quot;png&quot;, resolution=300):
    path = os.path.join(IMAGES_PATH, fig_id + &quot;.&quot; + fig_extension)
    print(&quot;Saving figure&quot;, fig_id)
    if tight_layout:
        plt.tight_layout()
    plt.savefig(path, format=fig_extension, dpi=resolution)
</code></pre>
<h1 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h1><p><strong>Warning:</strong> since Scikit-Learn 0.24, <code>fetch_openml()</code> returns a Pandas <code>DataFrame</code> by default. To avoid this and keep the same code as in the book, we use <code>as_frame=False</code>.<br>警告:因为Scikit-Learn 0.24, fetch_openml()返回一个默认pandas DataFrame。为了避免这种情况,保持相同的代码,在书中,我们使用 as_frame &#x3D; False。</p>
<pre><code class="python">from sklearn.datasets import fetch_openml
mnist = fetch_openml(&#39;mnist_784&#39;, version=1, as_frame=False) #获取MNIST数据集
mnist.keys()
</code></pre>
<pre><code>dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;frame&#39;, &#39;categories&#39;, &#39;feature_names&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;details&#39;, &#39;url&#39;])
</code></pre>
<pre><code class="python">X, y = mnist[&quot;data&quot;], mnist[&quot;target&quot;]
X.shape
</code></pre>
<pre><code>(70000, 784)
</code></pre>
<pre><code class="python">y.shape
</code></pre>
<pre><code>(70000,)
</code></pre>
<pre><code class="python">28 * 28
</code></pre>
<pre><code>784
</code></pre>
<pre><code class="python">%matplotlib inline 
#允许图片正常显示 （魔法函数）
import matplotlib as mpl
import matplotlib.pyplot as plt

some_digit = X[0] #取出第一张图片
some_digit_image = some_digit.reshape(28, 28) #改变数组的形状,变成28*28 的数组
plt.imshow(some_digit_image, cmap=mpl.cm.binary) #设置色调
plt.axis(&quot;off&quot;) #关闭坐标轴

#save_fig(&quot;some_digit_plot&quot;) #plt.savefig(&quot;some_digit_plot&quot;) #将图片保存在本地
plt.show()
</code></pre>
<p>​<br><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_11_0.png" alt="png"><br>​    </p>
<pre><code class="python">y[0] #y标签为字符
</code></pre>
<pre><code>&#39;5&#39;
</code></pre>
<pre><code class="python">y = y.astype(np.uint8) #将y所有的数 转化为整数
</code></pre>
<pre><code class="python">y[0]
</code></pre>
<pre><code>5
</code></pre>
<pre><code class="python">def plot_digit(data):
    image = data.reshape(28, 28)
    plt.imshow(image, cmap = mpl.cm.binary,
               interpolation=&quot;nearest&quot;)
    plt.axis(&quot;off&quot;)
</code></pre>
<pre><code class="python"># EXTRA
def plot_digits(instances, images_per_row=10, **options):
    size = 28
    images_per_row = min(len(instances), images_per_row)
    images = [instance.reshape(size,size) for instance in instances]
    n_rows = (len(instances) - 1) // images_per_row + 1
    row_images = []
    n_empty = n_rows * images_per_row - len(instances)
    images.append(np.zeros((size, size * n_empty)))
    for row in range(n_rows):
        rimages = images[row * images_per_row : (row + 1) * images_per_row]
        row_images.append(np.concatenate(rimages, axis=1))
    image = np.concatenate(row_images, axis=0)
    plt.imshow(image, cmap = mpl.cm.binary, **options)
    plt.axis(&quot;off&quot;)
</code></pre>
<pre><code class="python">plt.figure(figsize=(9,9))
example_images = X[:100]
plot_digits(example_images, images_per_row=10)
save_fig(&quot;more_digits_plot&quot;)
plt.show()
</code></pre>
<pre><code>Saving figure more_digits_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_17_1.png" alt="png"></p>
<pre><code class="python">y[0]
</code></pre>
<pre><code>5
</code></pre>
<pre><code class="python">X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:] #前6w张为训练集，后一w张为测试集
</code></pre>
<h1 id="Binary-classifier-训练二元分类器"><a href="#Binary-classifier-训练二元分类器" class="headerlink" title="Binary classifier 训练二元分类器"></a>Binary classifier 训练二元分类器</h1><pre><code class="python">y_train_5 = (y_train == 5) #把数据为5的设置为1，否则为0
y_test_5 = (y_test == 5)
</code></pre>
<p><strong>Note</strong>: some hyperparameters will have a different defaut value in future versions of Scikit-Learn, such as <code>max_iter</code> and <code>tol</code>. To be future-proof, we explicitly set these hyperparameters to their future default values. For simplicity, this is not shown in the book.</p>
<p>注意:一些hyperparameters将有一个不同的Scikit-Learn defaut价值在未来的版本中,如max_iter和tol。不会过时,我们显式地设置这些hyperparameters他们未来的默认值。为简单起见,这不是这本书所示。</p>
<p>挑选一个分类器开始训练，一个好的初始选择是随机梯度下降（SGD）分类器，使用Scikit-learn的SGDClassifier类即可。</p>
<p>SGDClassifier参数属性方法介绍 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60983320">https://zhuanlan.zhihu.com/p/60983320</a></p>
<pre><code class="python">from sklearn.linear_model import SGDClassifier 
#创建一个SGDClassifier并在整个训练集上训练
sgd_clf = SGDClassifier(max_iter=1000, tol=1e-3, random_state=42) 
#max_iter最大迭代次数 tol训练结束的误差边界 random_state数据打乱的方式
sgd_clf.fit(X_train, y_train_5) #随机梯度下降法拟合线性模型
</code></pre>
<pre><code>SGDClassifier(random_state=42)
</code></pre>
<pre><code class="python">sgd_clf.predict([some_digit]) #判断some_digit是不是5 some_digit 为X[0]
</code></pre>
<pre><code>array([ True])
</code></pre>
<h2 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h2><h3 id="使用交叉验证测量准确率"><a href="#使用交叉验证测量准确率" class="headerlink" title="使用交叉验证测量准确率"></a>使用交叉验证测量准确率</h3><pre><code class="python">from sklearn.model_selection import cross_val_score
cross_val_score(sgd_clf, X_train, y_train_5, cv=3, scoring=&quot;accuracy&quot;)#评估SGDClassifier模型
#采用k-折交叉验证 cv：几折交叉验证 soring：调用方法(包括accuracy和mean_squared_error等等)
</code></pre>
<pre><code>array([0.95035, 0.96035, 0.9604 ])
</code></pre>
<pre><code class="python">#自己实现交叉验证
from sklearn.model_selection import StratifiedKFold
from sklearn.base import clone

skfolds = StratifiedKFold(n_splits=3, shuffle=True, random_state=42)

for train_index, test_index in skfolds.split(X_train, y_train_5):
    clone_clf = clone(sgd_clf)
    X_train_folds = X_train[train_index]
    y_train_folds = y_train_5[train_index]
    X_test_fold = X_train[test_index]
    y_test_fold = y_train_5[test_index]

    clone_clf.fit(X_train_folds, y_train_folds)
    y_pred = clone_clf.predict(X_test_fold)
    n_correct = sum(y_pred == y_test_fold)
    print(n_correct / len(y_pred))
</code></pre>
<pre><code>0.9669
0.91625
0.96785
</code></pre>
<p><strong>Note</strong>: <code>shuffle=True</code> was omitted by mistake in previous releases of the book.</p>
<p>注意:sguffle &#x3D; True省略了错误在之前的版本的书。</p>
<pre><code class="python">from sklearn.base import BaseEstimator #测试非5的分类器
class Never5Classifier(BaseEstimator):
    def fit(self, X, y=None):
        pass
    def predict(self, X):
        return np.zeros((len(X), 1), dtype=bool)
</code></pre>
<pre><code class="python">never_5_clf = Never5Classifier()
cross_val_score(never_5_clf, X_train, y_train_5, cv=3, scoring=&quot;accuracy&quot;)
</code></pre>
<pre><code>array([0.91125, 0.90855, 0.90915])
</code></pre>
<p>可以看出准确率超过了90%，因为数字5的图片在全部图片中占比10%，如果抄一张图片不是5，你的正确率就有90%。说明准确率通常无法成为分类器的首要性能指标，特别是你处理有偏数据集时（即某些类比其它类更为频繁）。</p>
<p><strong>Warning</strong>: this output (and many others in this notebook and other notebooks) may differ slightly from those in the book. Don’t worry, that’s okay! There are several reasons for this:</p>
<p>警告:此输出(和许多其他笔记本和其他笔记本)从这些书中可能会略有不同。别担心,没关系!有几个原因:</p>
<ul>
<li>first, Scikit-Learn and other libraries evolve, and algorithms get tweaked a bit, which may change the exact result you get. If you use the latest Scikit-Learn version (and in general, you really should), you probably won’t be using the exact same version I used when I wrote the book or this notebook, hence the difference. I try to keep this notebook reasonably up to date, but I can’t change the numbers on the pages in your copy of the book.</li>
<li>second, many training algorithms are stochastic, meaning they rely on randomness. In principle, it’s possible to get consistent outputs from a random number generator by setting the seed from which it generates the pseudo-random numbers (which is why you will see <code>random_state=42</code> or <code>np.random.seed(42)</code> pretty often). However, sometimes this does not suffice due to the other factors listed here.</li>
<li>third, if the training algorithm runs across multiple threads (as do some algorithms implemented in C) or across multiple processes (e.g., when using the <code>n_jobs</code> argument), then the precise order in which operations will run is not always guaranteed, and thus the exact result may vary slightly.</li>
<li>lastly, other things may prevent perfect reproducibility, such as Python dicts and sets whose order is not guaranteed to be stable across sessions, or the order of files in a directory which is also not guaranteed.</li>
</ul>
<ol>
<li>算法不断发展</li>
<li>许多训练算法是随机的</li>
<li>练算法跨多个线程运行或跨多个进程运行操作的精确运行顺序并不总是有保证的，因此精确的结果可能会略有不同。</li>
<li>其他事情可能会阻止完美的再现性，例如Python dict和set，它们的顺序不能保证在会话中是稳定的，或者目录中文件的顺序也不能保证。</li>
</ol>
<h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>评估分类器性能更好的方法时混淆矩阵</p>
<pre><code class="python">from sklearn.model_selection import cross_val_predicty_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3)#生成一组预测
</code></pre>
<pre><code class="python">from sklearn.metrics import confusion_matrixconfusion_matrix(y_train_5, y_train_pred)#生成混淆矩阵
</code></pre>
<pre><code>array([[53892,   687],
       [ 1891,  3530]], dtype=int64)
</code></pre>
<p>第一行表示所有非5（负类）：53892张被正确分为非5类别（真负类） 687张被错误的分成了5类别（假正类）<br>第二行表示所有5（正类）：1891张被错误分为非5类别（假负类） 3530张被正确的分为5类别（真正类）<br><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193313588.png" alt="image-20211013193313588"></p>
<pre><code class="python">y_train_perfect_predictions = y_train_5  # pretend we reached perfection
confusion_matrix(y_train_5, y_train_perfect_predictions)
#一个完美的分类器只有真正类和真负类
</code></pre>
<pre><code>array([[54579,     0],
       [    0,  5421]], dtype=int64)
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193342924.png" alt="image-20211013193342924"></p>
<pre><code class="python">from sklearn.metrics import precision_score, recall_score

precision_score(y_train_5, y_train_pred)
</code></pre>
<pre><code>0.8370879772350012
</code></pre>
<pre><code class="python">cm = confusion_matrix(y_train_5, y_train_pred)
cm[1, 1] / (cm[0, 1] + cm[1, 1])
</code></pre>
<pre><code>0.8370879772350012
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193400541.png" alt="image-20211013193400541"></p>
<pre><code class="python">recall_score(y_train_5, y_train_pred)
</code></pre>
<pre><code>0.6511713705958311
</code></pre>
<pre><code class="python">cm[1, 1] / (cm[1, 0] + cm[1, 1])
</code></pre>
<pre><code>0.6511713705958311
</code></pre>
<p>F1分数：将精度和召回率合成一个单一的指标</p>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193416652.png" alt="image-20211013193416652"></p>
<p>F1：将准确率和召回率合成一个单一的指标，F1分数是精度和召回率的谐波平均值。正常的平均值平等对待所有值，而谐波平均值会给予低值更高的权重。因此只有当召回率和精度都很高时，分类器才能得到较高的F1值。</p>
<p>F1分数对那些具有相近精度和召回率的分类器更有利。</p>
<pre><code class="python">from sklearn.metrics import f1_score

f1_score(y_train_5, y_train_pred)
</code></pre>
<pre><code>0.7325171197343846
</code></pre>
<pre><code class="python">cm[1, 1] / (cm[1, 1] + (cm[1, 0] + cm[0, 1]) / 2)
</code></pre>
<pre><code>0.7325171197343847
</code></pre>
<p>精度&#x2F;召回率权衡</p>
<p>在精度&#x2F;召回率的权衡中，图像按照分值排名，分值高于阈值被认为时正的。阈值越高，召回率越低，精度越高。</p>
<pre><code class="python">y_scores = sgd_clf.decision_function([some_digit])#打分 scores
y_scores
</code></pre>
<pre><code>array([2164.22030239])
</code></pre>
<pre><code class="python">threshold = 0 #比如设置阈值为0 大于就是5 小于就不是5
y_some_digit_pred = (y_scores &gt; threshold)
</code></pre>
<pre><code class="python">y_some_digit_pred
</code></pre>
<pre><code>array([ True])
</code></pre>
<pre><code class="python">threshold = 8000 #设置阈值为8000
y_some_digit_pred = (y_scores &gt; threshold)
y_some_digit_pred
</code></pre>
<pre><code>array([False])
</code></pre>
<pre><code class="python">y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3,
                             method=&quot;decision_function&quot;) #获取训练集中所有实例的分数
</code></pre>
<p>计算不同阈值下的precision和recall</p>
<pre><code class="python">from sklearn.metrics import precision_recall_curve

precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)#计算所有可能的阈值的精度和召回率
</code></pre>
<p>使用Matplotlib绘制精度和召回率相对阈值的函数图</p>
<pre><code class="python">def plot_precision_recall_vs_threshold(precisions, recalls, thresholds):
    plt.plot(thresholds, precisions[:-1], &quot;b--&quot;, label=&quot;Precision&quot;, linewidth=2)
    plt.plot(thresholds, recalls[:-1], &quot;g-&quot;, label=&quot;Recall&quot;, linewidth=2)
    plt.legend(loc=&quot;center right&quot;, fontsize=16) # Not shown in the book
    plt.xlabel(&quot;Threshold&quot;, fontsize=16)        # Not shown
    plt.grid(True)                              # Not shown
    plt.axis([-50000, 50000, 0, 1])             # Not shown



recall_90_precision = recalls[np.argmax(precisions &gt;= 0.90)]
threshold_90_precision = thresholds[np.argmax(precisions &gt;= 0.90)]


plt.figure(figsize=(8, 4))                                                                  # Not shown
plot_precision_recall_vs_threshold(precisions, recalls, thresholds)
plt.plot([threshold_90_precision, threshold_90_precision], [0., 0.9], &quot;r:&quot;)                 # Not shown
plt.plot([-50000, threshold_90_precision], [0.9, 0.9], &quot;r:&quot;)                                # Not shown
plt.plot([-50000, threshold_90_precision], [recall_90_precision, recall_90_precision], &quot;r:&quot;)# Not shown
plt.plot([threshold_90_precision], [0.9], &quot;ro&quot;)                                             # Not shown
plt.plot([threshold_90_precision], [recall_90_precision], &quot;ro&quot;)                             # Not shown
save_fig(&quot;precision_recall_vs_threshold_plot&quot;)                                              # Not shown
plt.show()
</code></pre>
<pre><code>Saving figure precision_recall_vs_threshold_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_61_1.png" alt="png"></p>
<pre><code class="python">(y_train_pred == (y_scores &gt; 0)).all()
</code></pre>
<pre><code>True
</code></pre>
<pre><code class="python">def plot_precision_vs_recall(precisions, recalls):
    plt.plot(recalls, precisions, &quot;b-&quot;, linewidth=2)
    plt.xlabel(&quot;Recall&quot;, fontsize=16)
    plt.ylabel(&quot;Precision&quot;, fontsize=16)
    plt.axis([0, 1, 0, 1])
    plt.grid(True)

plt.figure(figsize=(8, 6))
plot_precision_vs_recall(precisions, recalls)
plt.plot([recall_90_precision, recall_90_precision], [0., 0.9], &quot;r:&quot;)
plt.plot([0.0, recall_90_precision], [0.9, 0.9], &quot;r:&quot;)
plt.plot([recall_90_precision], [0.9], &quot;ro&quot;)
save_fig(&quot;precision_vs_recall_plot&quot;)
plt.show()
</code></pre>
<pre><code>Saving figure precision_vs_recall_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_63_1.png" alt="png"></p>
<pre><code class="python">threshold_90_precision = thresholds[np.argmax(precisions &gt;= 0.90)]
</code></pre>
<pre><code class="python">threshold_90_precision
</code></pre>
<pre><code>3370.0194991439557
</code></pre>
<pre><code class="python">y_train_pred_90 = (y_scores &gt;= threshold_90_precision)
</code></pre>
<pre><code class="python">precision_score(y_train_5, y_train_pred_90)
</code></pre>
<pre><code>0.9000345901072293
</code></pre>
<pre><code class="python">recall_score(y_train_5, y_train_pred_90)
</code></pre>
<pre><code>0.4799852425751706
</code></pre>
<h1 id="ROC-curves-ROC曲线"><a href="#ROC-curves-ROC曲线" class="headerlink" title="ROC curves ROC曲线"></a>ROC curves ROC曲线</h1><p>经常与二元分类器一起使用。<br>受试者工作特征曲线 （receiver operating characteristic curve，简称ROC曲线），又称为感受性曲线（sensitivity curve）。得此名的原因在于曲线上各点反映着相同的感受性，它们都是对同一信号刺激的反应，只不过是在几种不同的判定标准下所得的结果而已。</p>
<p>ROC曲线简介：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26293316">https://zhuanlan.zhihu.com/p/26293316</a></p>
<p>真正类率（召回率的别称）  假正类率（FPR）  FPR为错误分为正类的负类实例比值</p>
<p>TNR 真负类 正确分类为负类的负类实例比例，也成为特异度</p>
<p>FPR &#x3D; 1 - TNR(真负类)</p>
<p>ROC曲线时灵敏度TPR（召回率）和FPR（1-特异度）的关系</p>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193512982.png" alt="image-20211013193512982"></p>
<pre><code class="python">from sklearn.metrics import roc_curve#Matplotlib绘制ROC曲线

fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)
print(fpr, tpr, thresholds)
</code></pre>
<pre><code>[0.         0.         0.         ... 0.99937705 0.99937705 1.        ] [0.00000000e+00 1.84467810e-04 9.22339052e-04 ... 9.99815532e-01
 1.00000000e+00 1.00000000e+00] [  49442.43765905   49441.43765905   36801.60697028 ... -105763.22240074
 -106527.45300471 -146348.56726174]
</code></pre>
<pre><code class="python">def plot_roc_curve(fpr, tpr, label=None):
    plt.plot(fpr, tpr, linewidth=2, label=label)
    plt.plot([0, 1], [0, 1], &#39;k--&#39;) # dashed diagonal
    plt.axis([0, 1, 0, 1])                                    # Not shown in the book
    plt.xlabel(&#39;False Positive Rate (Fall-Out)&#39;, fontsize=16) # Not shown
    plt.ylabel(&#39;True Positive Rate (Recall)&#39;, fontsize=16)    # Not shown
    plt.grid(True)                                            # Not shown

plt.figure(figsize=(8, 6))                                    # Not shown
plot_roc_curve(fpr, tpr)
fpr_90 = fpr[np.argmax(tpr &gt;= recall_90_precision)]           # Not shown
plt.plot([fpr_90, fpr_90], [0., recall_90_precision], &quot;r:&quot;)   # Not shown
plt.plot([0.0, fpr_90], [recall_90_precision, recall_90_precision], &quot;r:&quot;)  # Not shown
plt.plot([fpr_90], [recall_90_precision], &quot;ro&quot;)               # Not shown
save_fig(&quot;roc_curve_plot&quot;)                                    # Not shown
plt.show()
</code></pre>
<pre><code>Saving figure roc_curve_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_72_1.png" alt="png"></p>
<p>虚线表示随机分类器的ROC曲线，一个优秀的分类器应该离这条线越远越好（向左上角）</p>
<pre><code class="python">#测量曲线下面积（AUC）完美的ROC AUC等于1，而纯随机分类器ROC AUC为0.5 
from sklearn.metrics import roc_auc_score

roc_auc_score(y_train_5, y_scores)
</code></pre>
<pre><code>0.9604938554008616
</code></pre>
<p>ROC曲线和 精度&#x2F;召回率PR曲线 的选择</p>
<p>当正类非常少见或者你更关注假正类而不是假负类时，应该选择PR曲线，反之则是ROC曲线。</p>
<p><strong>Note</strong>: we set <code>n_estimators=100</code> to be future-proof since this will be the default value in Scikit-Learn 0.22.</p>
<p>我们将“n_estimators &#x3D; 100”是不会过时的,因为这将Scikit-Learn 0.22中的默认值。</p>
<p>训练随机森林分类器</p>
<pre><code class="python">from sklearn.ensemble import RandomForestClassifier
forest_clf = RandomForestClassifier(n_estimators=100, random_state=42)
y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=3,
                                    method=&quot;predict_proba&quot;)
</code></pre>
<pre><code class="python">y_scores_forest = y_probas_forest[:, 1] # score = proba of positive class
fpr_forest, tpr_forest, thresholds_forest = roc_curve(y_train_5,y_scores_forest)
</code></pre>
<pre><code class="python">recall_for_forest = tpr_forest[np.argmax(fpr_forest &gt;= fpr_90)]

plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, &quot;b:&quot;, linewidth=2, label=&quot;SGD&quot;)
plot_roc_curve(fpr_forest, tpr_forest, &quot;Random Forest&quot;)
plt.plot([fpr_90, fpr_90], [0., recall_90_precision], &quot;r:&quot;)
plt.plot([0.0, fpr_90], [recall_90_precision, recall_90_precision], &quot;r:&quot;)
plt.plot([fpr_90], [recall_90_precision], &quot;ro&quot;)
plt.plot([fpr_90, fpr_90], [0., recall_for_forest], &quot;r:&quot;)
plt.plot([fpr_90], [recall_for_forest], &quot;ro&quot;)
plt.grid(True)
plt.legend(loc=&quot;lower right&quot;, fontsize=16)
save_fig(&quot;roc_curve_comparison_plot&quot;)
plt.show()
</code></pre>
<pre><code>Saving figure roc_curve_comparison_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_80_1.png" alt="png"></p>
<pre><code class="python">roc_auc_score(y_train_5, y_scores_forest)
</code></pre>
<pre><code>0.9983436731328145
</code></pre>
<pre><code class="python">y_train_pred_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=3)
precision_score(y_train_5, y_train_pred_forest)
</code></pre>
<pre><code>0.9905083315756169
</code></pre>
<pre><code class="python">recall_score(y_train_5, y_train_pred_forest)
</code></pre>
<pre><code>0.8662608374838591
</code></pre>
<h1 id="Multiclass-classification-多类分类器（第五章详）"><a href="#Multiclass-classification-多类分类器（第五章详）" class="headerlink" title="Multiclass classification 多类分类器（第五章详）"></a>Multiclass classification 多类分类器（第五章详）</h1><p>可以区分两个以上的类</p>
<p>OVO:一对一</p>
<p>OVR:一对多</p>
<p>Scikit-Learn 可以检测到你尝试使用二元分类算法进行多任务分类，它会根据情况自动运行OvO或OvR</p>
<pre><code class="python">from sklearn.svm import SVC

svm_clf = SVC(gamma=&quot;auto&quot;, random_state=42)
svm_clf.fit(X_train[:1000], y_train[:1000]) # y_train, not y_train_5
svm_clf.predict([some_digit])
</code></pre>
<pre><code>array([5], dtype=uint8)
</code></pre>
<p>在内部Scikit-Learn实际上训练了45个二类分类器（OvR），获取它们对图片的决策，然后选择了分数最高的）</p>
<pre><code class="python">some_digit_scores = svm_clf.decision_function([some_digit])
some_digit_scores
#返回每一个类的分数而不是每一个分类器的分数
</code></pre>
<pre><code>array([[ 2.81585438,  7.09167958,  3.82972099,  0.79365551,  5.8885703 ,
         9.29718395,  1.79862509,  8.10392157, -0.228207  ,  4.83753243]])
</code></pre>
<pre><code class="python">np.argmax(some_digit_scores) #最高分对应的下标
</code></pre>
<pre><code>5
</code></pre>
<pre><code class="python">svm_clf.classes_ #查看一共有多少个类别
</code></pre>
<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint8)
</code></pre>
<pre><code class="python">svm_clf.classes_[5] #最高分的类别
</code></pre>
<pre><code>5
</code></pre>
<p>如果想要强制Scikit-Learn 使用一对一或一对多策略，可以使用OneVsOne-Classifier或OneVsRestClassifier类。只需要创建一个实例，然后将分类器传给其构造函数（不必须是二元分类器）。</p>
<p>例如，下面这段代码使用OvR策略，基于SVC创建了一个多类分类器：</p>
<pre><code class="python">from sklearn.multiclass import OneVsRestClassifier
ovr_clf = OneVsRestClassifier(SVC(gamma=&quot;auto&quot;, random_state=42))
ovr_clf.fit(X_train[:1000], y_train[:1000])
ovr_clf.predict([some_digit])
</code></pre>
<pre><code>array([5], dtype=uint8)
</code></pre>
<pre><code class="python">len(ovr_clf.estimators_)
</code></pre>
<pre><code>10
</code></pre>
<pre><code class="python">sgd_clf.fit(X_train, y_train)#训练随机梯度下降模型
sgd_clf.predict([some_digit])
</code></pre>
<pre><code>array([3], dtype=uint8)
</code></pre>
<pre><code class="python">sgd_clf.decision_function([some_digit]
</code></pre>
<pre><code>array([[-31893.03095419, -34419.69069632,  -9530.63950739,
          1823.73154031, -22320.14822878,  -1385.80478895,
        -26188.91070951, -16147.51323997,  -4604.35491274,
        -12050.767298  ]])
</code></pre>
<p><strong>Warning</strong>: the following two cells may take close to 30 minutes to run, or more depending on your hardware.</p>
<p>以下两个单元可能需要将近30分钟的时间来运行，具体时间取决于您的硬件。</p>
<p>使用交叉验证来评估SGDClassifer的准确性</p>
<pre><code class="python">cross_val_score(sgd_clf, X_train, y_train, cv=3, scoring=&quot;accuracy&quot;)
</code></pre>
<pre><code>array([0.87365, 0.85835, 0.8689 ])
</code></pre>
<p>将输入进行简单缩放可以将准确率提高到89以上</p>
<pre><code class="python">from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))
cross_val_score(sgd_clf, X_train_scaled, y_train, cv=3, scoring=&quot;accuracy&quot;)
</code></pre>
<pre><code>array([0.8983, 0.891 , 0.9018])
</code></pre>
<h1 id="Error-analysis-误差分析"><a href="#Error-analysis-误差分析" class="headerlink" title="Error analysis 误差分析"></a>Error analysis 误差分析</h1><pre><code class="python">y_train_pred = cross_val_predict(sgd_clf, X_train_scaled, y_train, cv=3)#计算y的预测值
conf_mx = confusion_matrix(y_train, y_train_pred)#计算混淆矩阵
conf_mx
</code></pre>
<pre><code>array([[5577,    0,   22,    5,    8,   43,   36,    6,  225,    1],
       [   0, 6400,   37,   24,    4,   44,    4,    7,  212,   10],
       [  27,   27, 5220,   92,   73,   27,   67,   36,  378,   11],
       [  22,   17,  117, 5227,    2,  203,   27,   40,  403,   73],
       [  12,   14,   41,    9, 5182,   12,   34,   27,  347,  164],
       [  27,   15,   30,  168,   53, 4444,   75,   14,  535,   60],
       [  30,   15,   42,    3,   44,   97, 5552,    3,  131,    1],
       [  21,   10,   51,   30,   49,   12,    3, 5684,  195,  210],
       [  17,   63,   48,   86,    3,  126,   25,   10, 5429,   44],
       [  25,   18,   30,   64,  118,   36,    1,  179,  371, 5107]],
      dtype=int64)
</code></pre>
<pre><code class="python">y_train_pred
</code></pre>
<pre><code>array([3, 0, 4, ..., 5, 6, 8], dtype=uint8)
</code></pre>
<pre><code class="python"># since sklearn 0.22, you can use sklearn.metrics.plot_confusion_matrix()
def plot_confusion_matrix(matrix):
    &quot;&quot;&quot;If you prefer color and a colorbar&quot;&quot;&quot;
    fig = plt.figure(figsize=(8,8))
    ax = fig.add_subplot(111)
    cax = ax.matshow(matrix)
    fig.colorbar(cax)
</code></pre>
<pre><code class="python">plt.matshow(conf_mx, cmap=plt.cm.gray)
save_fig(&quot;confusion_matrix_plot&quot;, tight_layout=False)
plt.show()
#大多数图片都在对角线上，说明他们被正确的分类
#数字5 看起来比其他的数字稍微暗一点，这可能是因为5的图片可能比较少，或者是分类器在数字5上效果不如其他数字
</code></pre>
<pre><code>Saving figure confusion_matrix_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_105_1.png" alt="png"></p>
<p>让我们把焦点放错误上</p>
<p>首先，需要将混淆矩阵中的每一个值除以相应类中的图片数量，这样比较的就是错误率而不是错误的绝对值（后者对图片较多的类不公平）</p>
<pre><code class="python">row_sums = conf_mx.sum(axis=1, keepdims=True)
norm_conf_mx = conf_mx / row_sums
</code></pre>
<pre><code class="python">row_sums
</code></pre>
<pre><code>array([[5923],
       [6742],
       [5958],
       [6131],
       [5842],
       [5421],
       [5918],
       [6265],
       [5851],
       [5949]], dtype=int64)
</code></pre>
<pre><code class="python">np.fill_diagonal(norm_conf_mx, 0) #用零填充对角线，重新绘制结果
plt.matshow(norm_conf_mx, cmap=plt.cm.gray)
save_fig(&quot;confusion_matrix_errors_plot&quot;, tight_layout=False)
plt.show()
</code></pre>
<pre><code>Saving figure confusion_matrix_errors_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_109_1.png" alt="png"></p>
<p>第8列很亮说明，有许多的图片被错误的分类成8了，但第8行不那么差，实际上数字8 被正确分为了8</p>
<pre><code class="python">cl_a, cl_b = 3, 5
X_aa = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_a)]
X_ab = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_b)]
X_ba = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_a)]
X_bb = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_b)]

plt.figure(figsize=(8,8))
plt.subplot(221); plot_digits(X_aa[:25], images_per_row=5)
plt.subplot(222); plot_digits(X_ab[:25], images_per_row=5)
plt.subplot(223); plot_digits(X_ba[:25], images_per_row=5)
plt.subplot(224); plot_digits(X_bb[:25], images_per_row=5)
save_fig(&quot;error_analysis_digits_plot&quot;)
plt.show()
</code></pre>
<pre><code>Saving figure error_analysis_digits_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_111_1.png" alt="png"></p>
<h1 id="Multilabel-classification-多标签分类"><a href="#Multilabel-classification-多标签分类" class="headerlink" title="Multilabel classification 多标签分类"></a>Multilabel classification 多标签分类</h1><pre><code class="python">from sklearn.neighbors import KNeighborsClassifier

y_train_large = (y_train &gt;= 7) #是否是大数
y_train_odd = (y_train % 2 == 1)#是否是奇数
y_multilabel = np.c_[y_train_large, y_train_odd]

knn_clf = KNeighborsClassifier()
knn_clf.fit(X_train, y_multilabel)
</code></pre>
<pre><code>KNeighborsClassifier()
</code></pre>
<pre><code class="python">y_multilabel
</code></pre>
<pre><code>array([[False,  True],
       [False, False],
       [False, False],
       ...,
       [False,  True],
       [False, False],
       [ True, False]])
</code></pre>
<pre><code class="python">knn_clf.predict([some_digit]) #不是大数，是奇数
</code></pre>
<pre><code>array([[False,  True]])
</code></pre>
<p><strong>Warning</strong>: the following cell may take a very long time (possibly hours depending on your hardware).</p>
<p>下面的计算单元可能需要很长时间(可能需要几个小时，这取决于您的硬件)。</p>
<pre><code class="python">y_train_knn_pred = cross_val_predict(knn_clf, X_train, y_multilabel, cv=3)
f1_score(y_multilabel, y_train_knn_pred, average=&quot;macro&quot;)
</code></pre>
<pre><code>0.976410265560605
</code></pre>
<h1 id="Multioutput-多输出分类"><a href="#Multioutput-多输出分类" class="headerlink" title="Multioutput  多输出分类"></a>Multioutput  多输出分类</h1><pre><code class="python">noise = np.random.randint(0, 100, (len(X_train), 784))
X_train_mod = X_train + noise
noise = np.random.randint(0, 100, (len(X_test), 784))
X_test_mod = X_test + noise
y_train_mod = X_train
y_test_mod = X_test
</code></pre>
<pre><code class="python">some_index = 0
plt.subplot(121); plot_digit(X_test_mod[some_index])
plt.subplot(122); plot_digit(y_test_mod[some_index])
save_fig(&quot;noisy_digit_example_plot&quot;)
plt.show()
</code></pre>
<pre><code>Saving figure noisy_digit_example_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_120_1.png" alt="png"></p>
<p>使用Numpy的randint()函数为MNIST图片的像素争强 左边是有噪声的，右边是干净的</p>
<p>通过训练分类器，清洗这张图片。</p>
<pre><code class="python">knn_clf.fit(X_train_mod, y_train_mod)
clean_digit = knn_clf.predict([X_test_mod[some_index]])
plot_digit(clean_digit)
save_fig(&quot;cleaned_digit_example_plot&quot;)
</code></pre>
<pre><code>Saving figure cleaned_digit_example_plot
</code></pre>
<p><img src="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_122_1.png" alt="png"></p>
<p>书籍：深度学习四大名著之《机器学习实战：基于Scikit-Learn、Keras和TensorFlow》第二版</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/dog.jpg" height=300 width=300></img>
                    <p>John Doe</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        
                            
                                <dd><a href="https://github.com/22ha0" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                            
                            
                            
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">19 <p>Articles</p></a></li>
                    <li><a href="/categories">1 <p>Categories</p></a></li>
                    <li><a href="/tags">22 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Setup"><span class="toc-number">1.</span> <span class="toc-text">Setup</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MNIST"><span class="toc-number">2.</span> <span class="toc-text">MNIST</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Binary-classifier-%E8%AE%AD%E7%BB%83%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">Binary classifier 训练二元分类器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">性能测量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B5%8B%E9%87%8F%E5%87%86%E7%A1%AE%E7%8E%87"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用交叉验证测量准确率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5"><span class="toc-number">3.1.2.</span> <span class="toc-text">混淆矩阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ROC-curves-ROC%E6%9B%B2%E7%BA%BF"><span class="toc-number">4.</span> <span class="toc-text">ROC curves ROC曲线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Multiclass-classification-%E5%A4%9A%E7%B1%BB%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%A6%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">Multiclass classification 多类分类器（第五章详）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Error-analysis-%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">Error analysis 误差分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Multilabel-classification-%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">Multilabel classification 多标签分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Multioutput-%E5%A4%9A%E8%BE%93%E5%87%BA%E5%88%86%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">Multioutput  多输出分类</span></a></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2023
        <span class="gradient-text">
            John Doe
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.3" target="_blank" rel="noopener">v1.4.9.3</a></small>
        
        </br>
        
        <span class="gradient-text">
            <a href="https://beian.miit.gov.cn/" title="beian.miit.gov.cn" target="_blank" rel="noopener">beian.miit.gov.cn</a>
        </span>
        
        
        </br>
        <span style="display: inline-block;"> <img src=/null></span>
        
        <span class="gradient-text">
            <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010602009049" title="www.beian.gov.cn&#x2F;portal&#x2F;registerSystemInfo?recordcode&#x3D;44010602009049" target="_blank" rel="noopener">www.beian.gov.cn&#x2F;portal&#x2F;registerSystemInfo?recordcode&#x3D;44010602009049</a>
        </span>
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
