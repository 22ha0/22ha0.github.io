<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【论文笔记&amp;总结】（AlexNet）ImageNet Classification with Deep Convolutional Neural Networks</title>
      <link href="/2023/07/01/alexnet%E8%AE%BA%E6%96%87/"/>
      <url>/2023/07/01/alexnet%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 论文总结&amp;笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlexNet </tag>
            
            <tag> Deep Learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitHub搭建Hexo个人博客</title>
      <link href="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>之前使用服务器搭建个人博客的流程可以参考：<a href="https://22ha0.github.io/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">Windows 10+阿里云服务器+HEXO 搭建个人博客</a></p><h3 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a><strong>Hexo + GitHub 文章发布原理</strong></h3><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/v2-a193a47cf70fe6ecf156e5f3d34920ea_1440w.jpeg" class title="img"><h1 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1. 搭建环境"></a>1. 搭建环境</h1><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p><ul><li><p>Node.js：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></p></li><li><p>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p></li></ul><p>安装完成后可以输入 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code> 并回车，如下图出现程序版本号即可。</p><h1 id="2-连接Github"><a href="#2-连接Github" class="headerlink" title="2. 连接Github"></a>2. 连接Github</h1><p>右键 -&gt; Git Bash Here，<strong>设置用户名和邮箱</strong>：</p><pre><code class="bash">git config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot;</code></pre><p><strong>创建 SSH 密匙</strong>：</p><p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p><p><strong>添加密匙：</strong></p><p>进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面（在用户的Setting中而不是项目的），选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230627105537790.png" class title="image-20230627105537790"><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230627111504168.png" class title="image-20230627111504168"><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230627111520350.png" class title="image-20230627111520350"><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。</p><p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230627111611730.png" class title="image-20230627111611730"><h2 id="3-创建-Github-Pages-仓库"><a href="#3-创建-Github-Pages-仓库" class="headerlink" title="3. 创建 Github Pages 仓库"></a>3. 创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code> </li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/v2-67a8165154f4c5f4a6333e76e78ed815_1440w.webp" class title="img"><h1 id="4-本地安装-Hexo-博客程序"><a href="#4-本地安装-Hexo-博客程序" class="headerlink" title="4. 本地安装 Hexo 博客程序"></a>4. 本地安装 Hexo 博客程序</h1><p>新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。</p><h2 id="4-1-安装-Hexo"><a href="#4-1-安装-Hexo" class="headerlink" title="4.1 安装 Hexo"></a>4.1 安装 Hexo</h2><p>使用 npm 一键安装 Hexo 博客程序：</p><pre><code class="text">npm install -g hexo-cli</code></pre><h2 id="4-2-Hexo-初始化和本地预览"><a href="#4-2-Hexo-初始化和本地预览" class="headerlink" title="4.2 Hexo 初始化和本地预览"></a>4.2 Hexo 初始化和本地预览</h2><p><strong>初始化并安装所需组件：</strong></p><pre><code class="text">hexo init      # 初始化npm install    # 安装组件</code></pre><p>完成后依次输入下面命令，<strong>启动本地服务器进行预览</strong>：</p><pre><code class="text">hexo g   # 生成页面hexo s   # 启动预览</code></pre><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><p><strong>Tips：</strong>如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p><p>Hexo 博客文件夹目录结构如下：</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230627111721851.png" class title="image-20230627111721851"><h1 id="5-部署-Hexo-到-GitHub-Pages"><a href="#5-部署-Hexo-到-GitHub-Pages" class="headerlink" title="5. 部署 Hexo 到 GitHub Pages"></a>5. 部署 Hexo 到 GitHub Pages</h1><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>如果要使得branch中的master生效，需要到项目的setting中pages的<strong>Branch</strong>设置为<code>master</code>。</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230627112241664.png" class title="image-20230627112241664"><p>首先<strong>安装 hexo-deployer-git</strong>：</p><pre><code class="text">npm install hexo-deployer-git --save</code></pre><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><pre><code class="text">deploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: master</code></pre><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h1 id="6-绑定域名（可选）"><a href="#6-绑定域名（可选）" class="headerlink" title="6. 绑定域名（可选）"></a>6. 绑定域名（可选）</h1><p>博客搭建完成使用的是 GitHub 的子域名（用户名.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a>），我们可以为 Hexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于 SEO。</p><p>我们使用 <a href="https://link.zhihu.com/?target=https://www.namesilo.com/?rid=d27fa32do">Namesilo</a> 进行注册，便宜好用没啥套路，使用优惠码 <code>okoff</code> 优惠一美元，com 域名大概 50 块一年。</p><h2 id="6-1-域名注册和解析"><a href="#6-1-域名注册和解析" class="headerlink" title="6.1 域名注册和解析"></a>6.1 域名注册和解析</h2><ul><li>域名注册和解析教程：<a href="https://zhuanlan.zhihu.com/p/33921436">Namesilo 域名购买及使用教程</a></li></ul><p>按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加 CNAME 记录将 www 域名解析指向 <code>用户名.github.io</code>。</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/v2-d5d37c8ad523d8ab5c7c200fabc9585e_1440w.webp" class title="img"><h2 id="6-2-绑定域名到-Hexo-博客"><a href="#6-2-绑定域名到-Hexo-博客" class="headerlink" title="6.2 绑定域名到 Hexo 博客"></a>6.2 绑定域名到 Hexo 博客</h2><p>进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如 <a href="http://www.example.com,保存名称为/">http://www.example.com，保存名称为</a> “CNAME”，格式为 “所有文件”（无 .txt 后缀）。</p><p>清除缓存等文件并重新发布网站：</p><pre><code class="text">hexo clean   # 清除缓存文件等hexo g       # 生成页面hexo s       # 启动预览</code></pre><p>现在就可以使用自己的域名访问 Hexo 博客了。</p><h2 id="6-3-开启-HTTPS"><a href="#6-3-开启-HTTPS" class="headerlink" title="6.3 开启 HTTPS"></a>6.3 开启 HTTPS</h2><p>配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub 仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce HTTPS。</p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/v2-54f8744afc9746884e6b3acecfc5f8cf_1440w.webp" class title="img"><p>HTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS 配置完成！</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo图片路径不解析-解决图片路径不一致不显示问题</title>
      <link href="/2023/06/26/Hexo-Typora-%E5%BC%80%E5%8F%91Hexo%E6%8F%92%E4%BB%B6-%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
      <url>/2023/06/26/Hexo-Typora-%E5%BC%80%E5%8F%91Hexo%E6%8F%92%E4%BB%B6-%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
      
        <content type="html"><![CDATA[<p>在本次搭建博客的过程中图片路径不解析，导致图片不显示</p><p>解决办法：</p><p>1.在Hexo根目录的_config.yml中的<code>post_asset_folder</code>设置为<code>true</code>，这样修改后，每次<code>hexo new page</code>生成新文章，都会在文章文件同级目录创建一个与文章文件名同名的文件夹，我们就在这里存放此文章的图片。</p><img src="/2023/06/26/Hexo-Typora-%E5%BC%80%E5%8F%91Hexo%E6%8F%92%E4%BB%B6-%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E4%B8%8D%E4%B8%80%E8%87%B4/image-20230626235737574.png" class title="image-20230626235737574"><p>2.Typora中的设置参考：<a href="https://22ha0.github.io/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/">参考链接</a></p><p>3.在<code>node_modules</code>文件夹下创建文件夹<code>hexo-asset-img</code>，初始化npm包</p><pre><code class="shell">mkdir hexo-asset-imgcd hexo-asset-imgnpm init</code></pre><p>根据提示输入信息</p><pre><code class="bash">$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help init` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (hexo-asset-img)version: (1.0.0)description: 转换图片路径entry point: (index.js)test command:git repository:keywords: hexoauthor: zzzlicense: (ISC) MITAbout to write to D:\22ha0\node_modules\hexo-asset-img\package.json:&#123;  &quot;name&quot;: &quot;hexo-asset-img&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;转换图片路径&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;keywords&quot;: [    &quot;hexo&quot;  ],  &quot;author&quot;: &quot;zzz&quot;,  &quot;license&quot;: &quot;MIT&quot;&#125;Is this OK? (yes)</code></pre><p>4.编写插件index.js</p><p>创建 <code>index.js</code>，编写代码如下:</p><pre><code class="javascript">const log = require(&#39;hexo-log&#39;)(&#123; &#39;debug&#39;: false, &#39;slient&#39;: false &#125;);/** * md文件返回 true * @param &#123;*&#125; data  */function ignore(data) &#123;    // TODO: 好奇怪，试了一下, md返回true, 但却需要忽略 取反!    var source = data.source;    var ext = source.substring(source.lastIndexOf(&#39;.&#39;)).toLowerCase();    return [&#39;md&#39;,].indexOf(ext) &gt; -1;&#125;function action(data) &#123;    var reverseSource = data.source.split(&quot;&quot;).reverse().join(&quot;&quot;);    var fileName = reverseSource.substring(3, reverseSource.indexOf(&quot;/&quot;)).split(&quot;&quot;).reverse().join(&quot;&quot;);    // ![example](postname/example.jpg)  --&gt;  &#123;% asset_img example.jpg example %&#125;    var regExp = RegExp(&quot;!\\[(.*?)\\]\\(&quot; + fileName + &#39;/(.+?)\\)&#39;, &quot;g&quot;);    // hexo g    data.content = data.content.replace(regExp, &quot;&#123;% asset_img $2 $1 %&#125;&quot;,&quot;g&quot;);    // log.info(`hexo-asset-img: filename: $&#123;fileName&#125;, title: $&#123;data.title.trim()&#125;`);        return data;&#125;hexo.extend.filter.register(&#39;before_post_render&#39;,(data)=&gt;&#123;    if(!ignore(data))&#123;        action(data)    &#125;&#125;, 0);</code></pre><p>5.<code>Hexo</code>根目录下 <code>package.json</code> 中 <code>dependencies</code>添加一行 <code>&quot;hexo-asset-img&quot;: &quot;^1.0.0&quot;</code>（不修改的话插件不会加载）</p><p>5.重新生成文章</p><pre><code class="javascript">hexo cleanhexo ghexo s # 本地预览</code></pre><p>参考链接：</p><p><a href="https://cloud.tencent.com/developer/article/1970544">https://cloud.tencent.com/developer/article/1970544</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo图片不显示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-链表（Linked List）</title>
      <link href="/2022/03/01/python-%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List%EF%BC%89/"/>
      <url>/2022/03/01/python-%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<pre><code class="python">class Node:         def __init__(self,data):        self.data = data        self.next = Noneclass LinkedList:        def __init__(self):        self.size = 0        self.head = None        self.last = None         def get(self,index): #get node        if index&lt;0 or index&gt;=self.size:            raise Exception(&quot;超出链表节点范围&quot;) #raise error        p = self.head        for i in range(index):            p = p.next        return p        def insert(self,data,index): #insert data        if index&lt;0 or index &gt; self.size:            raise Exception(&quot;超出链表节点范围&quot;) #raise error        node = Node(data)        if self.size == 0:            #Empty LinkedList            self.head = node            self.last = node        elif index == 0 :            #insert head            node.next = self.head            self.head = node        elif index == self.size:            #insert last            self.last.next = node            self.last = node        else:            #insert middle            prev_node = self.get(index-1)            node.next = prev_node.next            prev_node.next = node        self.size += 1        def remove(self,index):        if index&lt;0 or index&gt;=self.size:            raise Exception(&quot;超出链表节点范围&quot;) #raise error        if index == 0:            #remove head node            remove_node = self.head            self.head = self.head.next        elif index == self.size - 1:            #remove last node            prev_node = self.get(index - 1)            remove_node = prev_node.next            prev_node.next = None            self.last = prev_node        else:            #remove middle node            prev_node = self.get(index-1)            next_node = prev_node.next.next            remove_node = prev_node.next            prev_node.next = next_node        self.size -= 1        return remove_node    def output(self):        p = self.head        while p is not None:            print(p.data)            p = p.nextdef main():    linkedList = LinkedList()    linkedList.insert(3,0)    linkedList.insert(4,0)    linkedList.insert(5,0)    linkedList.insert(6,0)    linkedList.insert(3,1)    linkedList.output()    print()    linkedList.remove(0)    linkedList.output()    if __name__ == &quot;__main__&quot;:    main()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法例题-LeetCode-Java</title>
      <link href="/2022/01/09/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode-Java/"/>
      <url>/2022/01/09/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode-Java/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode经典题"><a href="#LeetCode经典题" class="headerlink" title="LeetCode经典题"></a>LeetCode经典题</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><h3 id="数组-amp-双指针"><a href="#数组-amp-双指针" class="headerlink" title="数组&amp;双指针"></a><strong>数组&amp;双指针</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/two-sum/">LeetCode 1. 两数之和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LeetCode 4. 寻找两个正序数组的中位数</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/3sum/">LeetCode 15. 三数之和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/sort-colors/">LeetCode 75. 颜色分类</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode 76. 最小覆盖子串</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/linked-list-cycle-ii/">LeetCode 142. 环形链表 II</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/palindrome-linked-list/">LeetCode 234. 回文链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/move-zeroes/">LeetCode 283. 移动零</a></li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode 19. 删除链表的倒数第 N 个结点</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/sort-list/">LeetCode 148. 排序链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">LeetCode 160. 相交链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/reverse-linked-list/">LeetCode 206. 反转链表</a></li></ol><h3 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列&amp;栈"></a><strong>队列&amp;栈</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/valid-parentheses/">LeetCode 20. 有效的括号</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/merge-two-sorted-lists/">LeetCode 21. 合并两个有序链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode 84. 柱状图中最大的矩形</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximal-rectangle/">LeetCode 85. 最大矩形</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/min-stack/">LeetCode 155. 最小栈</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/sliding-window-maximum/">LeetCode 239. 滑动窗口最大值</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/decode-string/">LeetCode 394. 字符串解码</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/daily-temperatures/">LeetCode 739. 每日温度</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3. 无重复字符的最长子串</a></li></ol><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><strong>哈希表</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/group-anagrams/">LeetCode 49. 字母异位词分组</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/linked-list-cycle/">LeetCode 141. 环形链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/lru-cache/">LeetCode 146. LRU 缓存机制</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/subarray-sum-equals-k/">LeetCode 560. 和为K的子数组</a></li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">LeetCode 94. 二叉树的中序遍历</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">LeetCode 104. 二叉树的最大深度</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. 从前序与中序遍历序列构造二叉树</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">LeetCode 114. 二叉树展开为链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/diameter-of-binary-tree/">LeetCode 543. 二叉树的直径</a></li></ol><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><strong>二叉搜索树</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode 96. 不同的二叉搜索树</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/validate-binary-search-tree/">LeetCode 98. 验证二叉搜索树</a></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a><strong>模拟</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/rotate-image/">LeetCode 48. 旋转图像</a></li></ol><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><strong>贪心</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/container-with-most-water/">LeetCode 11. 盛最多水的容器</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode 714. 买卖股票的最佳时机含手续费</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode 122. 买卖股票的最佳时机 II</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/jump-game/">LeetCode 55. 跳跃游戏</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode 309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/queue-reconstruction-by-height/">LeetCode 406. 根据身高重建队列</a></li></ol><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a><strong>二分</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">LeetCode 33. 搜索旋转排序数组</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</a></li></ol><h3 id="递归-amp-回溯"><a href="#递归-amp-回溯" class="headerlink" title="递归&amp;回溯"></a><strong>递归&amp;回溯</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">LeetCode 17. 电话号码的字母组合</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/generate-parentheses/">LeetCode 22. 括号生成</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/combination-sum/">LeetCode 39. 组合总和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/permutations/">LeetCode 46. 全排列</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/subsets/">LeetCode 78. 子集</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/word-search/">LeetCode 79. 单词搜索</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/invert-binary-tree/">LeetCode 226. 翻转二叉树</a></li></ol><h3 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a><strong>深度优先搜索DFS</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236. 二叉树的最近公共祖先</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/remove-invalid-parentheses/">LeetCode 301. 删除无效的括号</a></li></ol><h3 id="宽度优先搜索BFS"><a href="#宽度优先搜索BFS" class="headerlink" title="宽度优先搜索BFS"></a><strong>宽度优先搜索BFS</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/number-of-islands/">LeetCode 200. 岛屿数量</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/merge-two-binary-trees/">LeetCode 617. 合并二叉树</a></li></ol><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a><strong>分治</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-subarray/">LeetCode 53. 最大子序和</a></li></ol><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><strong>排序算法</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/merge-intervals/">LeetCode 56. 合并区间</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">LeetCode 215. 数组中的第K个最大元素</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/top-k-frequent-elements/">LeetCode 347. 前 K 个高频元素</a></li></ol><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a><strong>Manacher算法</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode 5. 最长回文子串</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/palindromic-substrings/">LeetCode 647. 回文子串</a></li></ol><h3 id="字典树Trie"><a href="#字典树Trie" class="headerlink" title="字典树Trie"></a><strong>字典树Trie</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/word-break/">LeetCode 139. 单词拆分</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/implement-trie-prefix-tree/">LeetCode 208. 实现 Trie (前缀树)</a></li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode 10. 正则表达式匹配</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-valid-parentheses/">LeetCode 32. 最长有效括号</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/trapping-rain-water/">LeetCode 42. 接雨水</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/unique-paths/">LeetCode 62. 不同路径</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/minimum-path-sum/">LeetCode 64. 最小路径和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/climbing-stairs/">LeetCode 70. 爬楼梯</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/edit-distance/">LeetCode 72. 编辑距离</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/word-break/">LeetCode 139. 单词拆分</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-product-subarray/">LeetCode 152. 乘积最大子数组</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/house-robber/">LeetCode 198. 打家劫舍</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximal-square/">LeetCode 221. 最大正方形</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-increasing-subsequence/">LeetCode 300. 最长递增子序列</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/house-robber-iii/">LeetCode 337. 打家劫舍 III</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/partition-equal-subset-sum/">LeetCode 416. 分割等和子集</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/target-sum/">LeetCode 494. 目标和</a></li></ol><h3 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a><strong>最短路算法</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/network-delay-time/">LeetCode 743. 网络延迟时间</a></li></ol><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a><strong>最小生成树</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></li></ol><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><strong><a href="https://www.zhihu.com/search?q=%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:388470520%7D">拓扑排序</a></strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/course-schedule/">LeetCode 207. 课程表</a></li></ol><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a><strong>并查集</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/evaluate-division/">LeetCode 399. 除法求值</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO V5 学习笔记</title>
      <link href="/2021/11/21/YOLO-V5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/21/YOLO-V5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>可以利用作者提供的requirements.txt 文件进行安装</p><p>利用 <code>pip install -r requirements.txt</code>安装环境</p><h1 id="Inference（推测）"><a href="#Inference（推测）" class="headerlink" title="Inference（推测）"></a>Inference（推测）</h1><p>命令行运行代码</p><pre><code class="bash">$ python detect.py --source 0  # webcam 输入源                            file.jpg  # image                             file.mp4  # video                            path/  # directory                            path/*.jpg  # glob                            &#39;https://youtu.be/NUsoVlDFqZg&#39;  # YouTube video                            &#39;rtsp://example.com/media.mp4&#39;  # RTSP, RTMP, HTTP stream</code></pre><p>运行在 <code>data/images</code>文件夹中的例子:</p><pre><code class="bash">$ python detect.py --source data/images --weights yolov5s.pt --conf 0.25Namespace(agnostic_nms=False, augment=False, classes=None, conf_thres=0.25, device=&#39;&#39;, exist_ok=False, img_size=640, iou_thres=0.45, name=&#39;exp&#39;, project=&#39;runs/detect&#39;, save_conf=False, save_txt=False, source=&#39;data/images/&#39;, update=False, view_img=False, weights=[&#39;yolov5s.pt&#39;])YOLOv5 v4.0-96-g83dc1b4 torch 1.7.0+cu101 CUDA:0 (Tesla V100-SXM2-16GB, 16160.5MB)Fusing layers... Model Summary: 224 layers, 7266973 parameters, 0 gradients, 17.0 GFLOPSimage 1/2 /content/yolov5/data/images/bus.jpg: 640x480 4 persons, 1 bus, Done. (0.010s)image 2/2 /content/yolov5/data/images/zidane.jpg: 384x640 2 persons, 1 tie, Done. (0.011s)Results saved to runs/detect/exp2Done. (0.103s)</code></pre><img src="undefined2021/11/21/YOLO-V5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/97107365-685a8d80-16c7-11eb-8c2e-83aac701d8b9.jpeg" width="500">  <h1 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h1><img src="/2021/11/21/YOLO-V5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211122172051386.png" class title="image-20211122172051386"><p>detect.py</p><pre><code class="python">&quot;&quot;&quot;    weights:训练的权重     source:测试数据，可以是图片/视频路径，也可以是&#39;0&#39;(电脑自带摄像头),也可以是rtsp等视频流    output:网络预测之后的图片/视频的保存路径    img-size:网络输入图片大小    conf-thres:置信度阈值 大于多少才显示出来    iou-thres:做nms的iou阈值 IoU交并比    device:设置设备    view-img:是否展示预测之后的图片/视频，默认False    save-txt:是否将预测的框坐标以txt文件形式保存，默认False    classes:设置只保留某一部分类别，形如0或者0 2 3    agnostic-nms:进行nms是否也去除不同类别之间的框，默认False    augment:推理的时候进行多尺度，翻转等操作(TTA)推理    update:如果为True，则对所有模型进行strip_optimizer操作，去除pt文件中的优化器等信息，默认为False            &quot;&quot;&quot;if __name__ == &#39;__main__&#39;:    parser = argparse.ArgumentParser()    parser.add_argument(&#39;--weights&#39;, nargs=&#39;+&#39;, type=str, default=&#39;yolov5s.pt&#39;, help=&#39;model.pt path(s)&#39;)    parser.add_argument(&#39;--source&#39;, type=str, default=&#39;data/images&#39;, help=&#39;source&#39;)  # file/folder, 0 for webcam    parser.add_argument(&#39;--img-size&#39;, type=int, default=640, help=&#39;inference size (pixels)&#39;)    parser.add_argument(&#39;--conf-thres&#39;, type=float, default=0.25, help=&#39;object confidence threshold&#39;)    parser.add_argument(&#39;--iou-thres&#39;, type=float, default=0.45, help=&#39;IOU threshold for NMS&#39;)    parser.add_argument(&#39;--device&#39;, default=&#39;&#39;, help=&#39;cuda device, i.e. 0 or 0,1,2,3 or cpu&#39;)    parser.add_argument(&#39;--view-img&#39;, action=&#39;store_true&#39;, help=&#39;display results&#39;)    parser.add_argument(&#39;--save-txt&#39;, action=&#39;store_true&#39;, help=&#39;save results to *.txt&#39;)    parser.add_argument(&#39;--save-conf&#39;, action=&#39;store_true&#39;, help=&#39;save confidences in --save-txt labels&#39;)    parser.add_argument(&#39;--nosave&#39;, action=&#39;store_true&#39;, help=&#39;do not save images/videos&#39;)    parser.add_argument(&#39;--classes&#39;, nargs=&#39;+&#39;, type=int, help=&#39;filter by class: --class 0, or --class 0 2 3&#39;)    parser.add_argument(&#39;--agnostic-nms&#39;, action=&#39;store_true&#39;, help=&#39;class-agnostic NMS&#39;)    parser.add_argument(&#39;--augment&#39;, action=&#39;store_true&#39;, help=&#39;augmented inference&#39;)    parser.add_argument(&#39;--update&#39;, action=&#39;store_true&#39;, help=&#39;update all models&#39;)    parser.add_argument(&#39;--project&#39;, default=&#39;runs/detect&#39;, help=&#39;save results to project/name&#39;)    parser.add_argument(&#39;--name&#39;, default=&#39;exp&#39;, help=&#39;save results to project/name&#39;)    parser.add_argument(&#39;--exist-ok&#39;, action=&#39;store_true&#39;, help=&#39;existing project/name ok, do not increment&#39;)    opt = parser.parse_args()    print(opt)    check_requirements(exclude=(&#39;pycocotools&#39;, &#39;thop&#39;))    with torch.no_grad():        if opt.update:  # update all models (to fix SourceChangeWarning)            for opt.weights in [&#39;yolov5s.pt&#39;, &#39;yolov5m.pt&#39;, &#39;yolov5l.pt&#39;, &#39;yolov5x.pt&#39;]:                detect()                strip_optimizer(opt.weights)        else:            detect()</code></pre><h1 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h1><p>超参数文件hyp解析</p><pre><code class="bash"># Hyperparameters for VOC finetuning# python train.py --batch 64 --weights yolov5m.pt --data voc.yaml --img 512 --epochs 50# See tutorials for hyperparameter evolution https://github.com/ultralytics/yolov5#tutorials# Hyperparameter Evolution Results# Generations: 51#                   P         R     mAP.5 mAP.5:.95       box       obj       cls# Metrics:      0.625     0.926      0.89     0.677    0.0111   0.00849   0.00124lr0: 0.00447  # 学习率lrf: 0.114    # 余弦退火超参数momentum: 0.873 # 学习率动量weight_decay: 0.00047 # 权重衰减系数giou: 0.0306 # giou损失的系数cls: 0.211 # 分类损失的系数cls_pw: 0.546 # 分类BCELoss中正样本的权重obj: 0.421 # 有无物体损失的系数obj_pw: 0.972 # 有无物体BCELoss中正样本的权重iou_t: 0.2 # 标签与anchors的iou阈值iou training thresholdanchor_t: 2.26 # 标签的长h宽w/anchor的长h_a宽w_a阈值, 即h/h_a, w/w_a都要在(1/2.26, 2.26)之间anchor-multiple threshold# anchors: 5.07fl_gamma: 0.0  # 设为0则表示不使用focal loss(efficientDet default is gamma=1.5)# 下面是一些数据增强的系数, 包括颜色空间和图片空间hsv_h: 0.0154 # 色调hsv_s: 0.9 # 饱和度hsv_v: 0.619 # 明度degrees: 0.404 #旋转角度translate: 0.206　 # 水平和垂直平移scale: 0.86　  # 缩放shear: 0.795  # 剪切perspective: 0.0  # 透视变换参数flipud: 0.00756  # 上下翻转fliplr: 0.5  # 左右翻转mixup: 0.153  # mixup系数</code></pre><p>training.py</p><pre><code class="python">    &quot;&quot;&quot;        opt参数解析：    weights：训练模型的路径（普通模型），也可以用自己的模型，为空就进行初始化    cfg:模型配置文件，网络结构    data:数据集配置文件，数据集路径，类名等，指定训练数据集    hyp:超参数文件     epochs:训练总轮次    batch-size:批次大小    img-size:输入图片分辨率大小    rect:是否采用矩形训练，默认False，进行填充    resume:接着打断训练上次的结果接着训练    nosave:不保存模型，默认False pt文件    notest:不进行test，默认False    noautoanchor:不自动调整anchor，默认False 添加锚点    evolve:是否进行超参数进化，默认False 寻找最优参数    bucket:谷歌云盘bucket，一般不会用到    cache-images:是否提前缓存图片到内存，以加快训练速度，默认False    image-weights:加载的权重文件    name:数据集名字，如果设置：results.txt to results_name.txt，默认无    device:训练的设备，cpu；0(表示一个gpu设备cuda:0)；0,1,2,3(多个gpu设备)    multi-scale:是否进行多尺度训练，默认False 对图片进行一个变换    single-cls:数据集是否只有一个类别，默认False    adam:是否使用adam优化器 如果没有选择就会选择随机梯度下降    sync-bn:是否使用跨卡同步BN,在DDP模式使用 分布式训练    local_rank:gpu编号    logdir:存放日志的目录    workers:dataloader的最大worker数量    quad :开启之后大于640测试的效果会比较好    linear-lr :学习速率的调整方式    label-smoothing:标签平滑，防止过拟合    save_period:是否开启W&amp;B    &quot;&quot;&quot;    if __name__ == &#39;__main__&#39;:    parser = argparse.ArgumentParser()    parser.add_argument(&#39;--weights&#39;, type=str, default=&#39;yolov5s.pt&#39;, help=&#39;initial weights path&#39;)    parser.add_argument(&#39;--cfg&#39;, type=str, default=&#39;&#39;, help=&#39;model.yaml path&#39;)    parser.add_argument(&#39;--data&#39;, type=str, default=&#39;data/coco128.yaml&#39;, help=&#39;data.yaml path&#39;)    parser.add_argument(&#39;--hyp&#39;, type=str, default=&#39;data/hyp.scratch.yaml&#39;, help=&#39;hyperparameters path&#39;)    parser.add_argument(&#39;--epochs&#39;, type=int, default=300)    parser.add_argument(&#39;--batch-size&#39;, type=int, default=16, help=&#39;total batch size for all GPUs&#39;)    parser.add_argument(&#39;--img-size&#39;, nargs=&#39;+&#39;, type=int, default=[640, 640], help=&#39;[train, test] image sizes&#39;)    parser.add_argument(&#39;--rect&#39;, action=&#39;store_true&#39;, help=&#39;rectangular training&#39;)    parser.add_argument(&#39;--resume&#39;, nargs=&#39;?&#39;, const=True, default=False, help=&#39;resume most recent training&#39;)    parser.add_argument(&#39;--nosave&#39;, action=&#39;store_true&#39;, help=&#39;only save final checkpoint&#39;)    parser.add_argument(&#39;--notest&#39;, action=&#39;store_true&#39;, help=&#39;only test final epoch&#39;)    parser.add_argument(&#39;--noautoanchor&#39;, action=&#39;store_true&#39;, help=&#39;disable autoanchor check&#39;)    parser.add_argument(&#39;--evolve&#39;, action=&#39;store_true&#39;, help=&#39;evolve hyperparameters&#39;)    parser.add_argument(&#39;--bucket&#39;, type=str, default=&#39;&#39;, help=&#39;gsutil bucket&#39;)    parser.add_argument(&#39;--cache-images&#39;, action=&#39;store_true&#39;, help=&#39;cache images for faster training&#39;)    parser.add_argument(&#39;--image-weights&#39;, action=&#39;store_true&#39;, help=&#39;use weighted image selection for training&#39;)    parser.add_argument(&#39;--device&#39;, default=&#39;&#39;, help=&#39;cuda device, i.e. 0 or 0,1,2,3 or cpu&#39;)    parser.add_argument(&#39;--multi-scale&#39;, action=&#39;store_true&#39;, help=&#39;vary img-size +/- 50%%&#39;)    parser.add_argument(&#39;--single-cls&#39;, action=&#39;store_true&#39;, help=&#39;train multi-class data as single-class&#39;)    parser.add_argument(&#39;--adam&#39;, action=&#39;store_true&#39;, help=&#39;use torch.optim.Adam() optimizer&#39;)    parser.add_argument(&#39;--sync-bn&#39;, action=&#39;store_true&#39;, help=&#39;use SyncBatchNorm, only available in DDP mode&#39;)    parser.add_argument(&#39;--local_rank&#39;, type=int, default=-1, help=&#39;DDP parameter, do not modify&#39;)    parser.add_argument(&#39;--workers&#39;, type=int, default=8, help=&#39;maximum number of dataloader workers&#39;)    parser.add_argument(&#39;--project&#39;, default=&#39;runs/train&#39;, help=&#39;save to project/name&#39;)    parser.add_argument(&#39;--entity&#39;, default=None, help=&#39;W&amp;B entity&#39;)    parser.add_argument(&#39;--name&#39;, default=&#39;exp&#39;, help=&#39;save to project/name&#39;)    parser.add_argument(&#39;--exist-ok&#39;, action=&#39;store_true&#39;, help=&#39;existing project/name ok, do not increment&#39;)    parser.add_argument(&#39;--quad&#39;, action=&#39;store_true&#39;, help=&#39;quad dataloader&#39;)    parser.add_argument(&#39;--linear-lr&#39;, action=&#39;store_true&#39;, help=&#39;linear LR&#39;)    parser.add_argument(&#39;--label-smoothing&#39;, type=float, default=0.0, help=&#39;Label smoothing epsilon&#39;)    parser.add_argument(&#39;--upload_dataset&#39;, action=&#39;store_true&#39;, help=&#39;Upload dataset as W&amp;B artifact table&#39;)    parser.add_argument(&#39;--bbox_interval&#39;, type=int, default=-1, help=&#39;Set bounding-box image logging interval for W&amp;B&#39;)    parser.add_argument(&#39;--save_period&#39;, type=int, default=-1, help=&#39;Log model after every &quot;save_period&quot; epoch&#39;)    parser.add_argument(&#39;--artifact_alias&#39;, type=str, default=&quot;latest&quot;, help=&#39;version of dataset artifact to be used&#39;)    opt = parser.parse_args()    # Set DDP variables    opt.world_size = int(os.environ[&#39;WORLD_SIZE&#39;]) if &#39;WORLD_SIZE&#39; in os.environ else 1    opt.global_rank = int(os.environ[&#39;RANK&#39;]) if &#39;RANK&#39; in os.environ else -1    set_logging(opt.global_rank)    if opt.global_rank in [-1, 0]:        check_git_status()        check_requirements()    # Resume    wandb_run = check_wandb_resume(opt)    if opt.resume and not wandb_run:  # resume an interrupted run        ckpt = opt.resume if isinstance(opt.resume, str) else get_latest_run()  # specified or most recent path        assert os.path.isfile(ckpt), &#39;ERROR: --resume checkpoint does not exist&#39;        apriori = opt.global_rank, opt.local_rank        with open(Path(ckpt).parent.parent / &#39;opt.yaml&#39;) as f:            opt = argparse.Namespace(**yaml.load(f, Loader=yaml.SafeLoader))  # replace        opt.cfg, opt.weights, opt.resume, opt.batch_size, opt.global_rank, opt.local_rank = &#39;&#39;, ckpt, True, opt.total_batch_size, *apriori  # reinstate        logger.info(&#39;Resuming training from %s&#39; % ckpt)    else:        # opt.hyp = opt.hyp or (&#39;hyp.finetune.yaml&#39; if opt.weights else &#39;hyp.scratch.yaml&#39;)        opt.data, opt.cfg, opt.hyp = check_file(opt.data), check_file(opt.cfg), check_file(opt.hyp)  # check files        assert len(opt.cfg) or len(opt.weights), &#39;either --cfg or --weights must be specified&#39;        opt.img_size.extend([opt.img_size[-1]] * (2 - len(opt.img_size)))  # extend to 2 sizes (train, test)        opt.name = &#39;evolve&#39; if opt.evolve else opt.name        opt.save_dir = increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok | opt.evolve)  # increment run    # DDP mode    opt.total_batch_size = opt.batch_size    device = select_device(opt.device, batch_size=opt.batch_size)    if opt.local_rank != -1:        assert torch.cuda.device_count() &gt; opt.local_rank        torch.cuda.set_device(opt.local_rank)        device = torch.device(&#39;cuda&#39;, opt.local_rank)        dist.init_process_group(backend=&#39;nccl&#39;, init_method=&#39;env://&#39;)  # distributed backend        assert opt.batch_size % opt.world_size == 0, &#39;--batch-size must be multiple of CUDA device count&#39;        opt.batch_size = opt.total_batch_size // opt.world_size    # Hyperparameters    with open(opt.hyp) as f:        hyp = yaml.load(f, Loader=yaml.SafeLoader)  # load hyps    # Train    logger.info(opt)    if not opt.evolve:        tb_writer = None  # init loggers        if opt.global_rank in [-1, 0]:            prefix = colorstr(&#39;tensorboard: &#39;)            logger.info(f&quot;&#123;prefix&#125;Start with &#39;tensorboard --logdir &#123;opt.project&#125;&#39;, view at http://localhost:6006/&quot;)            tb_writer = SummaryWriter(opt.save_dir)  # Tensorboard        train(hyp, opt, device, tb_writer)    # Evolve hyperparameters (optional)    else:        # Hyperparameter evolution metadata (mutation scale 0-1, lower_limit, upper_limit)        meta = &#123;&#39;lr0&#39;: (1, 1e-5, 1e-1),  # initial learning rate (SGD=1E-2, Adam=1E-3)                &#39;lrf&#39;: (1, 0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)                &#39;momentum&#39;: (0.3, 0.6, 0.98),  # SGD momentum/Adam beta1                &#39;weight_decay&#39;: (1, 0.0, 0.001),  # optimizer weight decay                &#39;warmup_epochs&#39;: (1, 0.0, 5.0),  # warmup epochs (fractions ok)                &#39;warmup_momentum&#39;: (1, 0.0, 0.95),  # warmup initial momentum                &#39;warmup_bias_lr&#39;: (1, 0.0, 0.2),  # warmup initial bias lr                &#39;box&#39;: (1, 0.02, 0.2),  # box loss gain                &#39;cls&#39;: (1, 0.2, 4.0),  # cls loss gain                &#39;cls_pw&#39;: (1, 0.5, 2.0),  # cls BCELoss positive_weight                &#39;obj&#39;: (1, 0.2, 4.0),  # obj loss gain (scale with pixels)                &#39;obj_pw&#39;: (1, 0.5, 2.0),  # obj BCELoss positive_weight                &#39;iou_t&#39;: (0, 0.1, 0.7),  # IoU training threshold                &#39;anchor_t&#39;: (1, 2.0, 8.0),  # anchor-multiple threshold                &#39;anchors&#39;: (2, 2.0, 10.0),  # anchors per output grid (0 to ignore)                &#39;fl_gamma&#39;: (0, 0.0, 2.0),  # focal loss gamma (efficientDet default gamma=1.5)                &#39;hsv_h&#39;: (1, 0.0, 0.1),  # image HSV-Hue augmentation (fraction)                &#39;hsv_s&#39;: (1, 0.0, 0.9),  # image HSV-Saturation augmentation (fraction)                &#39;hsv_v&#39;: (1, 0.0, 0.9),  # image HSV-Value augmentation (fraction)                &#39;degrees&#39;: (1, 0.0, 45.0),  # image rotation (+/- deg)                &#39;translate&#39;: (1, 0.0, 0.9),  # image translation (+/- fraction)                &#39;scale&#39;: (1, 0.0, 0.9),  # image scale (+/- gain)                &#39;shear&#39;: (1, 0.0, 10.0),  # image shear (+/- deg)                &#39;perspective&#39;: (0, 0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001                &#39;flipud&#39;: (1, 0.0, 1.0),  # image flip up-down (probability)                &#39;fliplr&#39;: (0, 0.0, 1.0),  # image flip left-right (probability)                &#39;mosaic&#39;: (1, 0.0, 1.0),  # image mixup (probability)                &#39;mixup&#39;: (1, 0.0, 1.0)&#125;  # image mixup (probability)        assert opt.local_rank == -1, &#39;DDP mode not implemented for --evolve&#39;        opt.notest, opt.nosave = True, True  # only test/save final epoch        # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices        yaml_file = Path(opt.save_dir) / &#39;hyp_evolved.yaml&#39;  # save best result here        if opt.bucket:            os.system(&#39;gsutil cp gs://%s/evolve.txt .&#39; % opt.bucket)  # download evolve.txt if exists        for _ in range(300):  # generations to evolve            if Path(&#39;evolve.txt&#39;).exists():  # if evolve.txt exists: select best hyps and mutate                # Select parent(s)                parent = &#39;single&#39;  # parent selection method: &#39;single&#39; or &#39;weighted&#39;                x = np.loadtxt(&#39;evolve.txt&#39;, ndmin=2)                n = min(5, len(x))  # number of previous results to consider                x = x[np.argsort(-fitness(x))][:n]  # top n mutations                w = fitness(x) - fitness(x).min()  # weights                if parent == &#39;single&#39; or len(x) == 1:                    # x = x[random.randint(0, n - 1)]  # random selection                    x = x[random.choices(range(n), weights=w)[0]]  # weighted selection                elif parent == &#39;weighted&#39;:                    x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # weighted combination                # Mutate                mp, s = 0.8, 0.2  # mutation probability, sigma                npr = np.random                npr.seed(int(time.time()))                g = np.array([x[0] for x in meta.values()])  # gains 0-1                ng = len(meta)                v = np.ones(ng)                while all(v == 1):  # mutate until a change occurs (prevent duplicates)                    v = (g * (npr.random(ng) &lt; mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)                for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)                    hyp[k] = float(x[i + 7] * v[i])  # mutate            # Constrain to limits            for k, v in meta.items():                hyp[k] = max(hyp[k], v[1])  # lower limit                hyp[k] = min(hyp[k], v[2])  # upper limit                hyp[k] = round(hyp[k], 5)  # significant digits            # Train mutation            results = train(hyp.copy(), opt, device)            # Write mutation results            print_mutation(hyp.copy(), results, yaml_file, opt.bucket)        # Plot results        plot_evolution(yaml_file)        print(f&#39;Hyperparameter evolution complete. Best results saved as: &#123;yaml_file&#125;\n&#39;              f&#39;Command to train a new model with these hyperparameters: $ python train.py --hyp &#123;yaml_file&#125;&#39;)</code></pre><p>训练结果保存在runs&#x2F;train目录下</p><pre><code>base.pt //选取在某个训练轮数最好的模型参数last.py //最后一轮训练的模型参数hyp.yaml //训练过程中模型的超参数labels.jpg //标注分布labels_correlogram.jpg //标注的相关矩阵opt.yaml //训练参数设置results.txt //训练的结果train_batch.jpg //训练的图片</code></pre><img src="/2021/11/21/YOLO-V5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211230104835262.png" class title="image-20211230104835262">]]></content>
      
      
      
        <tags>
            
            <tag> YOLO </tag>
            
            <tag> computer visual </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法例题&amp;LeetCode--Python</title>
      <link href="/2021/10/30/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode/"/>
      <url>/2021/10/30/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode/</url>
      
        <content type="html"><![CDATA[<h1 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1.贪心算法"></a>1.贪心算法</h1><h2 id="1-最优合并问题"><a href="#1-最优合并问题" class="headerlink" title="1 最优合并问题"></a>1 最优合并问题</h2><p> <strong>问题描述：</strong></p><p>给定k 个排好序的序列s1, s2 , …, sk, 用2 路合并算法将这k 个序列合并成一个序列。假设所采用的2 路合并算法合并2 个长度分别为m和n的序列需要m + n -1次比较。试设计一个算法确定合并这个序列的最优合并顺序，使所需的总比较次数最少。</p><p>为了进行比较，还需要确定合并这个序列的最差合并顺序，使所需的总比较次数最多。</p><p><strong>编程任务：</strong></p><p>对于给定的k个待合并序列，编程计算最多比较次数和最少比较次数合并方案。</p><p><strong>数据输入：</strong></p><p>由文件input.txt给出输入数据。第一行有1 个正整数k，表示有k个待合并序列。接下来的1 行中，有k个正整数，表示k个待合并序列的长度。</p><p><strong>结果输出</strong>:</p><p>将编程计算出的最多比较次数和最少比较次数输出到文件output.txt。</p><img src="/2021/10/30/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode/clip_image002.jpg" class title="img"><p><strong>思想</strong>：最小对比次数就为最小的先相加，最大的则相反，区别为求最小 每次都要排序，最大则不需要</p><p><strong>代码</strong></p><pre><code class="python">def readData(n):    Path = &#39;E:\桌面\新建文件夹\大三 上\大数据算法分析与设计/5-贪心算法-含测试数据\OPTIMAL MERGE\TEST\MERGE&#39;+str(n)+&#39;.IN&#39;    f = open(Path,&#39;r&#39;)    num = int(f.readline().strip(&#39;\n&#39;))    data = f.readline().strip(&#39;\n&#39;).split(&quot; &quot;)    data = [int(data[j]) for j in range(num)]    return datadef MINcount(data):    ANS=0    for i in range(len(data)-1):        data.sort()        A = data[0]+data[1]        ANS = ANS+A-1        data=data[2:]        data.append(A)    return ANSdef MAXcount(data):    ANS=0    data.sort()    for i in range(len(data)-1):        A = data[-1]+data[-2]        ANS = ANS+A-1        data=data[:-2]        data.append(A)    return ANSdef readANS(i):    Path = &quot;E:\桌面\新建文件夹\大三 上\大数据算法分析与设计/5-贪心算法-含测试数据\OPTIMAL MERGE\ANSWER\MERGE&quot;+str(i)+&quot;.OUT&quot;    f = open(Path,&quot;r&quot;)    ANS = f.readline().strip(&#39;\n&#39;).split(&quot; &quot;)    ANS = [int(ANS[i]) for i in range(len(ANS))]    return ANSdef main():    for i in range(0,11):        data = readData(i)        MIN = MINcount(data)        MAX = MAXcount(data)        ANS = readANS(i)        print(&quot;运算结果：&quot;,MAX,MIN,MAX == ANS[0] and MIN == ANS[1])if __name__ ==&#39;__main__&#39;:    main()</code></pre><h2 id="2-汽车加油问题"><a href="#2-汽车加油问题" class="headerlink" title="2 汽车加油问题"></a>2 汽车加油问题</h2><p> <strong>问题描述：</strong></p><p>一辆汽车加满油后可行驶n公里。旅途中有若干个加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数最少。并证明算法能产生一个最优解。</p><p> <strong>编程任务：</strong></p><p>对于给定的n和k个加油站位置，编程计算最少加油次数。</p><p> <strong>数据输入：</strong></p><p>由文件input.txt给出输入数据。第一行有2 个正整数n和k，表示汽车加满油后可行驶n公里，且旅途中有k个加油站。接下来的1 行中，有k+1 个整数，表示第k个加油站与第k-1 个加油站之间的距离。第0 个加油站表示出发地，汽车已加满油。第k+1 个加油站表示目的地。</p><p> <strong>结果输出</strong>:</p><p>将编程计算出的最少加油次数输出到文件output.txt。如果无法到达目的地，则输出”No Solution”。</p><img src="/2021/10/30/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode/clip_image004.jpg" class title="img"><p> <strong>代码</strong></p><pre><code class="python">def readData(i):    Path = &#39;E:\桌面\新建文件夹\大三 上\大数据算法分析与设计/5-贪心算法-含测试数据\OILING CAR\TEST\OIL&#39;+str(i)+&#39;.IN&#39;    f = open(Path,&#39;r&#39;)    tempData = f.readline().strip(&#39;\n&#39;).split(&#39; &#39;)    n,k = int(tempData[0]),int(tempData[1])    tempData = f.readline().strip(&#39;\n&#39;).split(&#39; &#39;)    data = [int(tempData[i]) for i in range(k+1)]    return n,k,datadef count(i):    Times = 0    Tn,k,data = readData(i)    n=Tn    for tempData in data:        if n&gt;=tempData:            n = n-tempData        else:            n=Tn            Times +=1            if n&lt;tempData:                return (&quot;No Solution!&quot;)            n = n-tempData    return Timesdef readANS(i):    Path = &#39;E:\桌面\新建文件夹\大三 上\大数据算法分析与设计/5-贪心算法-含测试数据\OILING CAR\ANSWER\OIL&#39;+str(i)+&#39;.OUT&#39;    f = open(Path,&#39;r&#39;)    tempData = f.readline().strip(&#39;\n&#39;)    return tempDatadef main():    for i in range(11):        Times = count(i)        ANS = readANS(i)        print(&quot;第&quot;+str(i)+&quot;个测试数据&quot;,&#39;运算结果：&#39;+str(Times),&#39;答案：&#39;+ANS)if __name__ ==&quot;__main__&quot;:    main()</code></pre><h2 id="实验5附加题-汽车加油问题（选做）"><a href="#实验5附加题-汽车加油问题（选做）" class="headerlink" title="实验5附加题-汽车加油问题（选做）"></a>实验5附加题-汽车加油问题（选做）</h2><p>力扣题号134：</p><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。<br><strong>示例 1:</strong></p><pre><code>输入: gas  = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: gas  = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/gas-station">https://leetcode-cn.com/problems/gas-station</a></p><p><strong>思路：</strong></p><p>爆破会超时，</p><p>参考LeetCode-陈允怀:</p><p>车子开完全程需要满足两个条件：</p><ul><li>车从i站能开到i+1</li><li>所有站里的油总量要》&#x3D;车子的总油耗</li></ul><p>假设从0号开始，一直到k都可以走完，在开往k+1时没油了，这时，应该将起点设为k+1站</p><p>问题1: 为什么应该将起始站点设为<code>k+1</code>？</p><ul><li>因为<code>k-&gt;k+1</code>站耗油太大，<code>0-&gt;k</code>站剩余油量都是不为负的，每减少一站，就少了一些剩余油量。所以如果从<code>k</code>前面的站点作为起始站，剩余油量不可能冲过<code>k+1</code>站。</li></ul><p>问题2:  为什么如果<code>k+1-&gt;end</code>全部可以正常通行，且<code>rest&gt;=0</code>就可以说明车子从<code>k+1</code>站点出发可以开完全程？</p><ul><li>因为，起始点将当前路径分为<code>A</code>、<code>B</code>两部分。其中，必然有(1)A部分剩余油量&lt;0。(2)B部分剩余油量&gt;0。</li><li>所以，无论多少个站，都可以抽象为两个站点（A、B）。(1)从B站加满油出发，(2)开往A站，车加油，(3)再开回B站的过程。</li></ul><p>重点：B剩余的油&gt;&#x3D;A缺少的总油。必然可以推出，B剩余的油&gt;&#x3D;A站点的每个子站点缺少的油。</p><p>1）整个过程分为[A, B]两阶段；2）总油量是足够的；3）B阶段还剩余油量，那么A阶段肯定是ok的。</p><p><strong>自己的理解：</strong>当B段走完时，run为剩余的油，当rest为总的剩余的油，A段需要的等于run-rest ,如果rest是大于0的 则A段需要的总油量小于B段剩余的油量 就可以走完。</p><p><strong>代码：</strong></p><pre><code class="python">def canCompleteCircuit(gas, cost):    rest,run,start = 0,0,0    for i in range(len(gas)):        run +=(gas[i]-cost[i])        rest +=(gas[i]-cost[i])        if run&lt;0:            start = i+1            run = 0    return (-1 if rest&lt;0 else start)def main():    gas  = [1,2,3,4,5]    cost = [3,4,5,1,2]    n = canCompleteCircuit(gas,cost)    print(n)if __name__ == &#39;__main__&#39;:    main()</code></pre><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode-53. 最大子序和"></a>LeetCode-<a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><pre><code>示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><p>思路：动态规划<br>是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans<br>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>如果 sum &lt;&#x3D; 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果<br>时间复杂度：O(n)</p><pre><code class="python">def maxSubArray(nums):    sum = 0    ans=nums[0]    for num in nums:        if sum&gt;0:            sum +=num        else :            sum = num        ans = max(sum,ans)    return ans        passdef main():    nums = [-2,1,-3,4,-1,2,1,-5,4]    ans = maxSubArray(nums)    print(ans)if __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="LeetCode-69-Sqrt-x"><a href="#LeetCode-69-Sqrt-x" class="headerlink" title="LeetCode-69. Sqrt(x)"></a>LeetCode-<a href="https://leetcode-cn.com/problems/sqrtx/">69. Sqrt(x)</a></h2><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：x = 4输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：x = 8输出：2解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</code></pre><p><strong>思路：</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。</p><p>为了叙述方便，我们用 C 表示待求出平方根的那个整数。显然，C 的平方根就是函数<img src="/2021/10/30/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode/image-20211031095838657.png" class title="image-20211031095838657">的零点。</p><p>牛顿迭代法的本质是借助泰勒级数，从初始值开始快速向零点逼近。我们任取一个 x0 作为初始值，在每一步的迭代中，我们找到函数图像上的点 (xi,f(xi))，过该点作一条斜率为该点导数 f′(xi)f’(x_i)f′(xi) 的直线，与横轴的交点记为 xi+1。xi+1相较于 xi而言距离零点更近。在经过多次迭代后，我们就可以得到一个距离零点非常接近的交点。下图给出了从 x0开始迭代两次，得到 x1 和 x2 的过程。</p><img src="/2021/10/30/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode/image-20211031100317623.png" class title="image-20211031100317623"><p><strong>算法：</strong></p><img src="/2021/10/30/%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98-LeetCode/image-20211031100917975.png" class title="image-20211031100917975"><p><strong>代码：</strong></p><pre><code class="python">def mySqrt(x):    if x == 0:        return 0    C,x0 = x,x    while True:        xi = 0.5*(x0+C/x0)        if abs(xi-x0)&lt;1e-7:            break        x0 = xi    return int(x0)def main():    x=9    n=mySqrt(x)    print(n)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="LeetCode-70-爬楼梯"><a href="#LeetCode-70-爬楼梯" class="headerlink" title="LeetCode-70. 爬楼梯"></a>LeetCode-<a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><p>示例 2：</p><pre><code>输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><p><strong>题解1：</strong>递归，但是递归要加上装饰器不然会超时</p><pre><code class="python">@functools.lru_cache(100) #该函数是一个装饰器，为函数提供缓存功能。在下次以相同参数调用时直接返回上一次的结果。</code></pre><pre><code class="python">import functools@functools.lru_cache(100) #该函数是一个装饰器，为函数提供缓存功能。在下次以相同参数调用时直接返回上一次的结果。def climbStairs(n):    return climbStairs(n-1)+climbStairs(n-2) if n &gt; 2 else ndef main():    n=100    m=climbStairs(n)    print(m)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>题解2：</strong>动态规划</p><p>  <strong>思路</strong><br>当走到i层时，只要加上i-2时的次数和i-1的次数<br>因为i-2层在跨2层，就到了i层，i-1层在跨1层，就到了i层<br>每次只能跨1层或者2层，所以把这两种情况相加就是有多少种情况可以到i层。</p><pre><code class="python">def climbStairs(n):    if n&lt;=2 :        return n    dp = [1,2]    for i in range(2,n):        dp.append(dp[i-1]+dp[i-2])    return dp[i]def main():    n=5    m=climbStairs(n)    print(m)if __name__ == &#39;__main__&#39;:    main()</code></pre><h1 id="LeetCode经典题"><a href="#LeetCode经典题" class="headerlink" title="LeetCode经典题"></a>LeetCode经典题</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><h3 id="数组-amp-双指针"><a href="#数组-amp-双指针" class="headerlink" title="数组&amp;双指针"></a><strong>数组&amp;双指针</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/two-sum/">LeetCode 1. 两数之和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LeetCode 4. 寻找两个正序数组的中位数</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/3sum/">LeetCode 15. 三数之和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/sort-colors/">LeetCode 75. 颜色分类</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode 76. 最小覆盖子串</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/linked-list-cycle-ii/">LeetCode 142. 环形链表 II</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/palindrome-linked-list/">LeetCode 234. 回文链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/move-zeroes/">LeetCode 283. 移动零</a></li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode 19. 删除链表的倒数第 N 个结点</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/sort-list/">LeetCode 148. 排序链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">LeetCode 160. 相交链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/reverse-linked-list/">LeetCode 206. 反转链表</a></li></ol><h3 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列&amp;栈"></a><strong>队列&amp;栈</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/valid-parentheses/">LeetCode 20. 有效的括号</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/merge-two-sorted-lists/">LeetCode 21. 合并两个有序链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode 84. 柱状图中最大的矩形</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximal-rectangle/">LeetCode 85. 最大矩形</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/min-stack/">LeetCode 155. 最小栈</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/sliding-window-maximum/">LeetCode 239. 滑动窗口最大值</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/decode-string/">LeetCode 394. 字符串解码</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/daily-temperatures/">LeetCode 739. 每日温度</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3. 无重复字符的最长子串</a></li></ol><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><strong>哈希表</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/group-anagrams/">LeetCode 49. 字母异位词分组</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/linked-list-cycle/">LeetCode 141. 环形链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/lru-cache/">LeetCode 146. LRU 缓存机制</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/subarray-sum-equals-k/">LeetCode 560. 和为K的子数组</a></li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">LeetCode 94. 二叉树的中序遍历</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">LeetCode 104. 二叉树的最大深度</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. 从前序与中序遍历序列构造二叉树</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">LeetCode 114. 二叉树展开为链表</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/diameter-of-binary-tree/">LeetCode 543. 二叉树的直径</a></li></ol><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><strong>二叉搜索树</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode 96. 不同的二叉搜索树</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/validate-binary-search-tree/">LeetCode 98. 验证二叉搜索树</a></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a><strong>模拟</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/rotate-image/">LeetCode 48. 旋转图像</a></li></ol><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><strong>贪心</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/container-with-most-water/">LeetCode 11. 盛最多水的容器</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode 714. 买卖股票的最佳时机含手续费</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode 122. 买卖股票的最佳时机 II</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/jump-game/">LeetCode 55. 跳跃游戏</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode 309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/queue-reconstruction-by-height/">LeetCode 406. 根据身高重建队列</a></li></ol><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a><strong>二分</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">LeetCode 33. 搜索旋转排序数组</a></li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</a></li></ol><h3 id="递归-amp-回溯"><a href="#递归-amp-回溯" class="headerlink" title="递归&amp;回溯"></a><strong>递归&amp;回溯</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">LeetCode 17. 电话号码的字母组合</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/generate-parentheses/">LeetCode 22. 括号生成</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/combination-sum/">LeetCode 39. 组合总和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/permutations/">LeetCode 46. 全排列</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/subsets/">LeetCode 78. 子集</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/word-search/">LeetCode 79. 单词搜索</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/invert-binary-tree/">LeetCode 226. 翻转二叉树</a></li></ol><h3 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a><strong>深度优先搜索DFS</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236. 二叉树的最近公共祖先</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/remove-invalid-parentheses/">LeetCode 301. 删除无效的括号</a></li></ol><h3 id="宽度优先搜索BFS"><a href="#宽度优先搜索BFS" class="headerlink" title="宽度优先搜索BFS"></a><strong>宽度优先搜索BFS</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/number-of-islands/">LeetCode 200. 岛屿数量</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/merge-two-binary-trees/">LeetCode 617. 合并二叉树</a></li></ol><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a><strong>分治</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-subarray/">LeetCode 53. 最大子序和</a></li></ol><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><strong>排序算法</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/merge-intervals/">LeetCode 56. 合并区间</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">LeetCode 215. 数组中的第K个最大元素</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/top-k-frequent-elements/">LeetCode 347. 前 K 个高频元素</a></li></ol><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a><strong>Manacher算法</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode 5. 最长回文子串</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/palindromic-substrings/">LeetCode 647. 回文子串</a></li></ol><h3 id="字典树Trie"><a href="#字典树Trie" class="headerlink" title="字典树Trie"></a><strong>字典树Trie</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/word-break/">LeetCode 139. 单词拆分</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/implement-trie-prefix-tree/">LeetCode 208. 实现 Trie (前缀树)</a></li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode 10. 正则表达式匹配</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-valid-parentheses/">LeetCode 32. 最长有效括号</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/trapping-rain-water/">LeetCode 42. 接雨水</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/unique-paths/">LeetCode 62. 不同路径</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/minimum-path-sum/">LeetCode 64. 最小路径和</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/climbing-stairs/">LeetCode 70. 爬楼梯</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/edit-distance/">LeetCode 72. 编辑距离</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/word-break/">LeetCode 139. 单词拆分</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-product-subarray/">LeetCode 152. 乘积最大子数组</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/house-robber/">LeetCode 198. 打家劫舍</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximal-square/">LeetCode 221. 最大正方形</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/longest-increasing-subsequence/">LeetCode 300. 最长递增子序列</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/house-robber-iii/">LeetCode 337. 打家劫舍 III</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/partition-equal-subset-sum/">LeetCode 416. 分割等和子集</a> </li><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/target-sum/">LeetCode 494. 目标和</a></li></ol><h3 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a><strong>最短路算法</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/network-delay-time/">LeetCode 743. 网络延迟时间</a></li></ol><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a><strong>最小生成树</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></li></ol><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><strong><a href="https://www.zhihu.com/search?q=%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:388470520%7D">拓扑排序</a></strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/course-schedule/">LeetCode 207. 课程表</a></li></ol><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a><strong>并查集</strong></h3><ol><li><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/evaluate-division/">LeetCode 399. 除法求值</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战-第三章-分类</title>
      <link href="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/"/>
      <url>/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>Chapter 3 – Classification</strong></p><p><em>This notebook contains all the sample code and solutions to the exercises in chapter 3.</em></p><h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><p>First, let’s import a few common modules, ensure MatplotLib plots figures inline and prepare a function to save the figures. We also check that Python 3.5 or later is installed (although Python 2.x may work, it is deprecated so we strongly recommend you use Python 3 instead), as well as Scikit-Learn ≥0.20.</p><pre><code class="python"># Python ≥3.5 is requiredimport sysassert sys.version_info &gt;= (3, 5)# Is this notebook running on Colab or Kaggle?IS_COLAB = &quot;google.colab&quot; in sys.modulesIS_KAGGLE = &quot;kaggle_secrets&quot; in sys.modules# Scikit-Learn ≥0.20 is requiredimport sklearnassert sklearn.__version__ &gt;= &quot;0.20&quot;# Common importsimport numpy as npimport os# to make this notebook&#39;s output stable across runsnp.random.seed(42)# To plot pretty figures%matplotlib inlineimport matplotlib as mplimport matplotlib.pyplot as pltmpl.rc(&#39;axes&#39;, labelsize=14)mpl.rc(&#39;xtick&#39;, labelsize=12)mpl.rc(&#39;ytick&#39;, labelsize=12)# Where to save the figuresPROJECT_ROOT_DIR = &quot;.&quot;CHAPTER_ID = &quot;classification&quot;IMAGES_PATH = os.path.join(PROJECT_ROOT_DIR, &quot;images&quot;, CHAPTER_ID)os.makedirs(IMAGES_PATH, exist_ok=True)def save_fig(fig_id, tight_layout=True, fig_extension=&quot;png&quot;, resolution=300):    path = os.path.join(IMAGES_PATH, fig_id + &quot;.&quot; + fig_extension)    print(&quot;Saving figure&quot;, fig_id)    if tight_layout:        plt.tight_layout()    plt.savefig(path, format=fig_extension, dpi=resolution)</code></pre><h1 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h1><p><strong>Warning:</strong> since Scikit-Learn 0.24, <code>fetch_openml()</code> returns a Pandas <code>DataFrame</code> by default. To avoid this and keep the same code as in the book, we use <code>as_frame=False</code>.<br>警告:因为Scikit-Learn 0.24, fetch_openml()返回一个默认pandas DataFrame。为了避免这种情况,保持相同的代码,在书中,我们使用 as_frame &#x3D; False。</p><pre><code class="python">from sklearn.datasets import fetch_openmlmnist = fetch_openml(&#39;mnist_784&#39;, version=1, as_frame=False) #获取MNIST数据集mnist.keys()</code></pre><pre><code>dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;frame&#39;, &#39;categories&#39;, &#39;feature_names&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;details&#39;, &#39;url&#39;])</code></pre><pre><code class="python">X, y = mnist[&quot;data&quot;], mnist[&quot;target&quot;]X.shape</code></pre><pre><code>(70000, 784)</code></pre><pre><code class="python">y.shape</code></pre><pre><code>(70000,)</code></pre><pre><code class="python">28 * 28</code></pre><pre><code>784</code></pre><pre><code class="python">%matplotlib inline #允许图片正常显示 （魔法函数）import matplotlib as mplimport matplotlib.pyplot as pltsome_digit = X[0] #取出第一张图片some_digit_image = some_digit.reshape(28, 28) #改变数组的形状,变成28*28 的数组plt.imshow(some_digit_image, cmap=mpl.cm.binary) #设置色调plt.axis(&quot;off&quot;) #关闭坐标轴#save_fig(&quot;some_digit_plot&quot;) #plt.savefig(&quot;some_digit_plot&quot;) #将图片保存在本地plt.show()</code></pre><p>​    </p><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_11_0.png" class title="png"><p>​    </p><pre><code class="python">y[0] #y标签为字符</code></pre><pre><code>&#39;5&#39;</code></pre><pre><code class="python">y = y.astype(np.uint8) #将y所有的数 转化为整数</code></pre><pre><code class="python">y[0]</code></pre><pre><code>5</code></pre><pre><code class="python">def plot_digit(data):    image = data.reshape(28, 28)    plt.imshow(image, cmap = mpl.cm.binary,               interpolation=&quot;nearest&quot;)    plt.axis(&quot;off&quot;)</code></pre><pre><code class="python"># EXTRAdef plot_digits(instances, images_per_row=10, **options):    size = 28    images_per_row = min(len(instances), images_per_row)    images = [instance.reshape(size,size) for instance in instances]    n_rows = (len(instances) - 1) // images_per_row + 1    row_images = []    n_empty = n_rows * images_per_row - len(instances)    images.append(np.zeros((size, size * n_empty)))    for row in range(n_rows):        rimages = images[row * images_per_row : (row + 1) * images_per_row]        row_images.append(np.concatenate(rimages, axis=1))    image = np.concatenate(row_images, axis=0)    plt.imshow(image, cmap = mpl.cm.binary, **options)    plt.axis(&quot;off&quot;)</code></pre><pre><code class="python">plt.figure(figsize=(9,9))example_images = X[:100]plot_digits(example_images, images_per_row=10)save_fig(&quot;more_digits_plot&quot;)plt.show()</code></pre><pre><code>Saving figure more_digits_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_17_1.png" class title="png"><pre><code class="python">y[0]</code></pre><pre><code>5</code></pre><pre><code class="python">X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:] #前6w张为训练集，后一w张为测试集</code></pre><h1 id="Binary-classifier-训练二元分类器"><a href="#Binary-classifier-训练二元分类器" class="headerlink" title="Binary classifier 训练二元分类器"></a>Binary classifier 训练二元分类器</h1><pre><code class="python">y_train_5 = (y_train == 5) #把数据为5的设置为1，否则为0y_test_5 = (y_test == 5)</code></pre><p><strong>Note</strong>: some hyperparameters will have a different defaut value in future versions of Scikit-Learn, such as <code>max_iter</code> and <code>tol</code>. To be future-proof, we explicitly set these hyperparameters to their future default values. For simplicity, this is not shown in the book.</p><p>注意:一些hyperparameters将有一个不同的Scikit-Learn defaut价值在未来的版本中,如max_iter和tol。不会过时,我们显式地设置这些hyperparameters他们未来的默认值。为简单起见,这不是这本书所示。</p><p>挑选一个分类器开始训练，一个好的初始选择是随机梯度下降（SGD）分类器，使用Scikit-learn的SGDClassifier类即可。</p><p>SGDClassifier参数属性方法介绍 <a href="https://zhuanlan.zhihu.com/p/60983320">https://zhuanlan.zhihu.com/p/60983320</a></p><pre><code class="python">from sklearn.linear_model import SGDClassifier #创建一个SGDClassifier并在整个训练集上训练sgd_clf = SGDClassifier(max_iter=1000, tol=1e-3, random_state=42) #max_iter最大迭代次数 tol训练结束的误差边界 random_state数据打乱的方式sgd_clf.fit(X_train, y_train_5) #随机梯度下降法拟合线性模型</code></pre><pre><code>SGDClassifier(random_state=42)</code></pre><pre><code class="python">sgd_clf.predict([some_digit]) #判断some_digit是不是5 some_digit 为X[0]</code></pre><pre><code>array([ True])</code></pre><h2 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h2><h3 id="使用交叉验证测量准确率"><a href="#使用交叉验证测量准确率" class="headerlink" title="使用交叉验证测量准确率"></a>使用交叉验证测量准确率</h3><pre><code class="python">from sklearn.model_selection import cross_val_scorecross_val_score(sgd_clf, X_train, y_train_5, cv=3, scoring=&quot;accuracy&quot;)#评估SGDClassifier模型#采用k-折交叉验证 cv：几折交叉验证 soring：调用方法(包括accuracy和mean_squared_error等等)</code></pre><pre><code>array([0.95035, 0.96035, 0.9604 ])</code></pre><pre><code class="python">#自己实现交叉验证from sklearn.model_selection import StratifiedKFoldfrom sklearn.base import cloneskfolds = StratifiedKFold(n_splits=3, shuffle=True, random_state=42)for train_index, test_index in skfolds.split(X_train, y_train_5):    clone_clf = clone(sgd_clf)    X_train_folds = X_train[train_index]    y_train_folds = y_train_5[train_index]    X_test_fold = X_train[test_index]    y_test_fold = y_train_5[test_index]    clone_clf.fit(X_train_folds, y_train_folds)    y_pred = clone_clf.predict(X_test_fold)    n_correct = sum(y_pred == y_test_fold)    print(n_correct / len(y_pred))</code></pre><pre><code>0.96690.916250.96785</code></pre><p><strong>Note</strong>: <code>shuffle=True</code> was omitted by mistake in previous releases of the book.</p><p>注意:sguffle &#x3D; True省略了错误在之前的版本的书。</p><pre><code class="python">from sklearn.base import BaseEstimator #测试非5的分类器class Never5Classifier(BaseEstimator):    def fit(self, X, y=None):        pass    def predict(self, X):        return np.zeros((len(X), 1), dtype=bool)</code></pre><pre><code class="python">never_5_clf = Never5Classifier()cross_val_score(never_5_clf, X_train, y_train_5, cv=3, scoring=&quot;accuracy&quot;)</code></pre><pre><code>array([0.91125, 0.90855, 0.90915])</code></pre><p>可以看出准确率超过了90%，因为数字5的图片在全部图片中占比10%，如果抄一张图片不是5，你的正确率就有90%。说明准确率通常无法成为分类器的首要性能指标，特别是你处理有偏数据集时（即某些类比其它类更为频繁）。</p><p><strong>Warning</strong>: this output (and many others in this notebook and other notebooks) may differ slightly from those in the book. Don’t worry, that’s okay! There are several reasons for this:</p><p>警告:此输出(和许多其他笔记本和其他笔记本)从这些书中可能会略有不同。别担心,没关系!有几个原因:</p><ul><li>first, Scikit-Learn and other libraries evolve, and algorithms get tweaked a bit, which may change the exact result you get. If you use the latest Scikit-Learn version (and in general, you really should), you probably won’t be using the exact same version I used when I wrote the book or this notebook, hence the difference. I try to keep this notebook reasonably up to date, but I can’t change the numbers on the pages in your copy of the book.</li><li>second, many training algorithms are stochastic, meaning they rely on randomness. In principle, it’s possible to get consistent outputs from a random number generator by setting the seed from which it generates the pseudo-random numbers (which is why you will see <code>random_state=42</code> or <code>np.random.seed(42)</code> pretty often). However, sometimes this does not suffice due to the other factors listed here.</li><li>third, if the training algorithm runs across multiple threads (as do some algorithms implemented in C) or across multiple processes (e.g., when using the <code>n_jobs</code> argument), then the precise order in which operations will run is not always guaranteed, and thus the exact result may vary slightly.</li><li>lastly, other things may prevent perfect reproducibility, such as Python dicts and sets whose order is not guaranteed to be stable across sessions, or the order of files in a directory which is also not guaranteed.</li></ul><ol><li>算法不断发展</li><li>许多训练算法是随机的</li><li>练算法跨多个线程运行或跨多个进程运行操作的精确运行顺序并不总是有保证的，因此精确的结果可能会略有不同。</li><li>其他事情可能会阻止完美的再现性，例如Python dict和set，它们的顺序不能保证在会话中是稳定的，或者目录中文件的顺序也不能保证。</li></ol><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>评估分类器性能更好的方法时混淆矩阵</p><pre><code class="python">from sklearn.model_selection import cross_val_predicty_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3)#生成一组预测</code></pre><pre><code class="python">from sklearn.metrics import confusion_matrixconfusion_matrix(y_train_5, y_train_pred)#生成混淆矩阵</code></pre><pre><code>array([[53892,   687],       [ 1891,  3530]], dtype=int64)</code></pre><p>第一行表示所有非5（负类）：53892张被正确分为非5类别（真负类） 687张被错误的分成了5类别（假正类）<br>第二行表示所有5（正类）：1891张被错误分为非5类别（假负类） 3530张被正确的分为5类别（真正类）</p><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193313588.png" class title="image-20211013193313588"><pre><code class="python">y_train_perfect_predictions = y_train_5  # pretend we reached perfectionconfusion_matrix(y_train_5, y_train_perfect_predictions)#一个完美的分类器只有真正类和真负类</code></pre><pre><code>array([[54579,     0],       [    0,  5421]], dtype=int64)</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193342924.png" class title="image-20211013193342924"><pre><code class="python">from sklearn.metrics import precision_score, recall_scoreprecision_score(y_train_5, y_train_pred)</code></pre><pre><code>0.8370879772350012</code></pre><pre><code class="python">cm = confusion_matrix(y_train_5, y_train_pred)cm[1, 1] / (cm[0, 1] + cm[1, 1])</code></pre><pre><code>0.8370879772350012</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193400541.png" class title="image-20211013193400541"><pre><code class="python">recall_score(y_train_5, y_train_pred)</code></pre><pre><code>0.6511713705958311</code></pre><pre><code class="python">cm[1, 1] / (cm[1, 0] + cm[1, 1])</code></pre><pre><code>0.6511713705958311</code></pre><p>F1分数：将精度和召回率合成一个单一的指标</p><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193416652.png" class title="image-20211013193416652"><p>F1：将准确率和召回率合成一个单一的指标，F1分数是精度和召回率的谐波平均值。正常的平均值平等对待所有值，而谐波平均值会给予低值更高的权重。因此只有当召回率和精度都很高时，分类器才能得到较高的F1值。</p><p>F1分数对那些具有相近精度和召回率的分类器更有利。</p><pre><code class="python">from sklearn.metrics import f1_scoref1_score(y_train_5, y_train_pred)</code></pre><pre><code>0.7325171197343846</code></pre><pre><code class="python">cm[1, 1] / (cm[1, 1] + (cm[1, 0] + cm[0, 1]) / 2)</code></pre><pre><code>0.7325171197343847</code></pre><p>精度&#x2F;召回率权衡</p><p>在精度&#x2F;召回率的权衡中，图像按照分值排名，分值高于阈值被认为时正的。阈值越高，召回率越低，精度越高。</p><pre><code class="python">y_scores = sgd_clf.decision_function([some_digit])#打分 scoresy_scores</code></pre><pre><code>array([2164.22030239])</code></pre><pre><code class="python">threshold = 0 #比如设置阈值为0 大于就是5 小于就不是5y_some_digit_pred = (y_scores &gt; threshold)</code></pre><pre><code class="python">y_some_digit_pred</code></pre><pre><code>array([ True])</code></pre><pre><code class="python">threshold = 8000 #设置阈值为8000y_some_digit_pred = (y_scores &gt; threshold)y_some_digit_pred</code></pre><pre><code>array([False])</code></pre><pre><code class="python">y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3,                             method=&quot;decision_function&quot;) #获取训练集中所有实例的分数</code></pre><p>计算不同阈值下的precision和recall</p><pre><code class="python">from sklearn.metrics import precision_recall_curveprecisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)#计算所有可能的阈值的精度和召回率</code></pre><p>使用Matplotlib绘制精度和召回率相对阈值的函数图</p><pre><code class="python">def plot_precision_recall_vs_threshold(precisions, recalls, thresholds):    plt.plot(thresholds, precisions[:-1], &quot;b--&quot;, label=&quot;Precision&quot;, linewidth=2)    plt.plot(thresholds, recalls[:-1], &quot;g-&quot;, label=&quot;Recall&quot;, linewidth=2)    plt.legend(loc=&quot;center right&quot;, fontsize=16) # Not shown in the book    plt.xlabel(&quot;Threshold&quot;, fontsize=16)        # Not shown    plt.grid(True)                              # Not shown    plt.axis([-50000, 50000, 0, 1])             # Not shownrecall_90_precision = recalls[np.argmax(precisions &gt;= 0.90)]threshold_90_precision = thresholds[np.argmax(precisions &gt;= 0.90)]plt.figure(figsize=(8, 4))                                                                  # Not shownplot_precision_recall_vs_threshold(precisions, recalls, thresholds)plt.plot([threshold_90_precision, threshold_90_precision], [0., 0.9], &quot;r:&quot;)                 # Not shownplt.plot([-50000, threshold_90_precision], [0.9, 0.9], &quot;r:&quot;)                                # Not shownplt.plot([-50000, threshold_90_precision], [recall_90_precision, recall_90_precision], &quot;r:&quot;)# Not shownplt.plot([threshold_90_precision], [0.9], &quot;ro&quot;)                                             # Not shownplt.plot([threshold_90_precision], [recall_90_precision], &quot;ro&quot;)                             # Not shownsave_fig(&quot;precision_recall_vs_threshold_plot&quot;)                                              # Not shownplt.show()</code></pre><pre><code>Saving figure precision_recall_vs_threshold_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_61_1.png" class title="png"><pre><code class="python">(y_train_pred == (y_scores &gt; 0)).all()</code></pre><pre><code>True</code></pre><pre><code class="python">def plot_precision_vs_recall(precisions, recalls):    plt.plot(recalls, precisions, &quot;b-&quot;, linewidth=2)    plt.xlabel(&quot;Recall&quot;, fontsize=16)    plt.ylabel(&quot;Precision&quot;, fontsize=16)    plt.axis([0, 1, 0, 1])    plt.grid(True)plt.figure(figsize=(8, 6))plot_precision_vs_recall(precisions, recalls)plt.plot([recall_90_precision, recall_90_precision], [0., 0.9], &quot;r:&quot;)plt.plot([0.0, recall_90_precision], [0.9, 0.9], &quot;r:&quot;)plt.plot([recall_90_precision], [0.9], &quot;ro&quot;)save_fig(&quot;precision_vs_recall_plot&quot;)plt.show()</code></pre><pre><code>Saving figure precision_vs_recall_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_63_1.png" class title="png"><pre><code class="python">threshold_90_precision = thresholds[np.argmax(precisions &gt;= 0.90)]</code></pre><pre><code class="python">threshold_90_precision</code></pre><pre><code>3370.0194991439557</code></pre><pre><code class="python">y_train_pred_90 = (y_scores &gt;= threshold_90_precision)</code></pre><pre><code class="python">precision_score(y_train_5, y_train_pred_90)</code></pre><pre><code>0.9000345901072293</code></pre><pre><code class="python">recall_score(y_train_5, y_train_pred_90)</code></pre><pre><code>0.4799852425751706</code></pre><h1 id="ROC-curves-ROC曲线"><a href="#ROC-curves-ROC曲线" class="headerlink" title="ROC curves ROC曲线"></a>ROC curves ROC曲线</h1><p>经常与二元分类器一起使用。<br>受试者工作特征曲线 （receiver operating characteristic curve，简称ROC曲线），又称为感受性曲线（sensitivity curve）。得此名的原因在于曲线上各点反映着相同的感受性，它们都是对同一信号刺激的反应，只不过是在几种不同的判定标准下所得的结果而已。</p><p>ROC曲线简介：<a href="https://zhuanlan.zhihu.com/p/26293316">https://zhuanlan.zhihu.com/p/26293316</a></p><p>真正类率（召回率的别称）  假正类率（FPR）  FPR为错误分为正类的负类实例比值</p><p>TNR 真负类 正确分类为负类的负类实例比例，也成为特异度</p><p>FPR &#x3D; 1 - TNR(真负类)</p><p>ROC曲线时灵敏度TPR（召回率）和FPR（1-特异度）的关系</p><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/image-20211013193512982.png" class title="image-20211013193512982"><pre><code class="python">from sklearn.metrics import roc_curve#Matplotlib绘制ROC曲线fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)print(fpr, tpr, thresholds)</code></pre><pre><code>[0.         0.         0.         ... 0.99937705 0.99937705 1.        ] [0.00000000e+00 1.84467810e-04 9.22339052e-04 ... 9.99815532e-01 1.00000000e+00 1.00000000e+00] [  49442.43765905   49441.43765905   36801.60697028 ... -105763.22240074 -106527.45300471 -146348.56726174]</code></pre><pre><code class="python">def plot_roc_curve(fpr, tpr, label=None):    plt.plot(fpr, tpr, linewidth=2, label=label)    plt.plot([0, 1], [0, 1], &#39;k--&#39;) # dashed diagonal    plt.axis([0, 1, 0, 1])                                    # Not shown in the book    plt.xlabel(&#39;False Positive Rate (Fall-Out)&#39;, fontsize=16) # Not shown    plt.ylabel(&#39;True Positive Rate (Recall)&#39;, fontsize=16)    # Not shown    plt.grid(True)                                            # Not shownplt.figure(figsize=(8, 6))                                    # Not shownplot_roc_curve(fpr, tpr)fpr_90 = fpr[np.argmax(tpr &gt;= recall_90_precision)]           # Not shownplt.plot([fpr_90, fpr_90], [0., recall_90_precision], &quot;r:&quot;)   # Not shownplt.plot([0.0, fpr_90], [recall_90_precision, recall_90_precision], &quot;r:&quot;)  # Not shownplt.plot([fpr_90], [recall_90_precision], &quot;ro&quot;)               # Not shownsave_fig(&quot;roc_curve_plot&quot;)                                    # Not shownplt.show()</code></pre><pre><code>Saving figure roc_curve_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_72_1.png" class title="png"><p>虚线表示随机分类器的ROC曲线，一个优秀的分类器应该离这条线越远越好（向左上角）</p><pre><code class="python">#测量曲线下面积（AUC）完美的ROC AUC等于1，而纯随机分类器ROC AUC为0.5 from sklearn.metrics import roc_auc_scoreroc_auc_score(y_train_5, y_scores)</code></pre><pre><code>0.9604938554008616</code></pre><p>ROC曲线和 精度&#x2F;召回率PR曲线 的选择</p><p>当正类非常少见或者你更关注假正类而不是假负类时，应该选择PR曲线，反之则是ROC曲线。</p><p><strong>Note</strong>: we set <code>n_estimators=100</code> to be future-proof since this will be the default value in Scikit-Learn 0.22.</p><p>我们将“n_estimators &#x3D; 100”是不会过时的,因为这将Scikit-Learn 0.22中的默认值。</p><p>训练随机森林分类器</p><pre><code class="python">from sklearn.ensemble import RandomForestClassifierforest_clf = RandomForestClassifier(n_estimators=100, random_state=42)y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=3,                                    method=&quot;predict_proba&quot;)</code></pre><pre><code class="python">y_scores_forest = y_probas_forest[:, 1] # score = proba of positive classfpr_forest, tpr_forest, thresholds_forest = roc_curve(y_train_5,y_scores_forest)</code></pre><pre><code class="python">recall_for_forest = tpr_forest[np.argmax(fpr_forest &gt;= fpr_90)]plt.figure(figsize=(8, 6))plt.plot(fpr, tpr, &quot;b:&quot;, linewidth=2, label=&quot;SGD&quot;)plot_roc_curve(fpr_forest, tpr_forest, &quot;Random Forest&quot;)plt.plot([fpr_90, fpr_90], [0., recall_90_precision], &quot;r:&quot;)plt.plot([0.0, fpr_90], [recall_90_precision, recall_90_precision], &quot;r:&quot;)plt.plot([fpr_90], [recall_90_precision], &quot;ro&quot;)plt.plot([fpr_90, fpr_90], [0., recall_for_forest], &quot;r:&quot;)plt.plot([fpr_90], [recall_for_forest], &quot;ro&quot;)plt.grid(True)plt.legend(loc=&quot;lower right&quot;, fontsize=16)save_fig(&quot;roc_curve_comparison_plot&quot;)plt.show()</code></pre><pre><code>Saving figure roc_curve_comparison_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_80_1.png" class title="png"><pre><code class="python">roc_auc_score(y_train_5, y_scores_forest)</code></pre><pre><code>0.9983436731328145</code></pre><pre><code class="python">y_train_pred_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=3)precision_score(y_train_5, y_train_pred_forest)</code></pre><pre><code>0.9905083315756169</code></pre><pre><code class="python">recall_score(y_train_5, y_train_pred_forest)</code></pre><pre><code>0.8662608374838591</code></pre><h1 id="Multiclass-classification-多类分类器（第五章详）"><a href="#Multiclass-classification-多类分类器（第五章详）" class="headerlink" title="Multiclass classification 多类分类器（第五章详）"></a>Multiclass classification 多类分类器（第五章详）</h1><p>可以区分两个以上的类</p><p>OVO:一对一</p><p>OVR:一对多</p><p>Scikit-Learn 可以检测到你尝试使用二元分类算法进行多任务分类，它会根据情况自动运行OvO或OvR</p><pre><code class="python">from sklearn.svm import SVCsvm_clf = SVC(gamma=&quot;auto&quot;, random_state=42)svm_clf.fit(X_train[:1000], y_train[:1000]) # y_train, not y_train_5svm_clf.predict([some_digit])</code></pre><pre><code>array([5], dtype=uint8)</code></pre><p>在内部Scikit-Learn实际上训练了45个二类分类器（OvR），获取它们对图片的决策，然后选择了分数最高的）</p><pre><code class="python">some_digit_scores = svm_clf.decision_function([some_digit])some_digit_scores#返回每一个类的分数而不是每一个分类器的分数</code></pre><pre><code>array([[ 2.81585438,  7.09167958,  3.82972099,  0.79365551,  5.8885703 ,         9.29718395,  1.79862509,  8.10392157, -0.228207  ,  4.83753243]])</code></pre><pre><code class="python">np.argmax(some_digit_scores) #最高分对应的下标</code></pre><pre><code>5</code></pre><pre><code class="python">svm_clf.classes_ #查看一共有多少个类别</code></pre><pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint8)</code></pre><pre><code class="python">svm_clf.classes_[5] #最高分的类别</code></pre><pre><code>5</code></pre><p>如果想要强制Scikit-Learn 使用一对一或一对多策略，可以使用OneVsOne-Classifier或OneVsRestClassifier类。只需要创建一个实例，然后将分类器传给其构造函数（不必须是二元分类器）。</p><p>例如，下面这段代码使用OvR策略，基于SVC创建了一个多类分类器：</p><pre><code class="python">from sklearn.multiclass import OneVsRestClassifierovr_clf = OneVsRestClassifier(SVC(gamma=&quot;auto&quot;, random_state=42))ovr_clf.fit(X_train[:1000], y_train[:1000])ovr_clf.predict([some_digit])</code></pre><pre><code>array([5], dtype=uint8)</code></pre><pre><code class="python">len(ovr_clf.estimators_)</code></pre><pre><code>10</code></pre><pre><code class="python">sgd_clf.fit(X_train, y_train)#训练随机梯度下降模型sgd_clf.predict([some_digit])</code></pre><pre><code>array([3], dtype=uint8)</code></pre><pre><code class="python">sgd_clf.decision_function([some_digit]</code></pre><pre><code>array([[-31893.03095419, -34419.69069632,  -9530.63950739,          1823.73154031, -22320.14822878,  -1385.80478895,        -26188.91070951, -16147.51323997,  -4604.35491274,        -12050.767298  ]])</code></pre><p><strong>Warning</strong>: the following two cells may take close to 30 minutes to run, or more depending on your hardware.</p><p>以下两个单元可能需要将近30分钟的时间来运行，具体时间取决于您的硬件。</p><p>使用交叉验证来评估SGDClassifer的准确性</p><pre><code class="python">cross_val_score(sgd_clf, X_train, y_train, cv=3, scoring=&quot;accuracy&quot;)</code></pre><pre><code>array([0.87365, 0.85835, 0.8689 ])</code></pre><p>将输入进行简单缩放可以将准确率提高到89以上</p><pre><code class="python">from sklearn.preprocessing import StandardScalerscaler = StandardScaler()X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))cross_val_score(sgd_clf, X_train_scaled, y_train, cv=3, scoring=&quot;accuracy&quot;)</code></pre><pre><code>array([0.8983, 0.891 , 0.9018])</code></pre><h1 id="Error-analysis-误差分析"><a href="#Error-analysis-误差分析" class="headerlink" title="Error analysis 误差分析"></a>Error analysis 误差分析</h1><pre><code class="python">y_train_pred = cross_val_predict(sgd_clf, X_train_scaled, y_train, cv=3)#计算y的预测值conf_mx = confusion_matrix(y_train, y_train_pred)#计算混淆矩阵conf_mx</code></pre><pre><code>array([[5577,    0,   22,    5,    8,   43,   36,    6,  225,    1],       [   0, 6400,   37,   24,    4,   44,    4,    7,  212,   10],       [  27,   27, 5220,   92,   73,   27,   67,   36,  378,   11],       [  22,   17,  117, 5227,    2,  203,   27,   40,  403,   73],       [  12,   14,   41,    9, 5182,   12,   34,   27,  347,  164],       [  27,   15,   30,  168,   53, 4444,   75,   14,  535,   60],       [  30,   15,   42,    3,   44,   97, 5552,    3,  131,    1],       [  21,   10,   51,   30,   49,   12,    3, 5684,  195,  210],       [  17,   63,   48,   86,    3,  126,   25,   10, 5429,   44],       [  25,   18,   30,   64,  118,   36,    1,  179,  371, 5107]],      dtype=int64)</code></pre><pre><code class="python">y_train_pred</code></pre><pre><code>array([3, 0, 4, ..., 5, 6, 8], dtype=uint8)</code></pre><pre><code class="python"># since sklearn 0.22, you can use sklearn.metrics.plot_confusion_matrix()def plot_confusion_matrix(matrix):    &quot;&quot;&quot;If you prefer color and a colorbar&quot;&quot;&quot;    fig = plt.figure(figsize=(8,8))    ax = fig.add_subplot(111)    cax = ax.matshow(matrix)    fig.colorbar(cax)</code></pre><pre><code class="python">plt.matshow(conf_mx, cmap=plt.cm.gray)save_fig(&quot;confusion_matrix_plot&quot;, tight_layout=False)plt.show()#大多数图片都在对角线上，说明他们被正确的分类#数字5 看起来比其他的数字稍微暗一点，这可能是因为5的图片可能比较少，或者是分类器在数字5上效果不如其他数字</code></pre><pre><code>Saving figure confusion_matrix_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_105_1.png" class title="png"><p>让我们把焦点放错误上</p><p>首先，需要将混淆矩阵中的每一个值除以相应类中的图片数量，这样比较的就是错误率而不是错误的绝对值（后者对图片较多的类不公平）</p><pre><code class="python">row_sums = conf_mx.sum(axis=1, keepdims=True)norm_conf_mx = conf_mx / row_sums</code></pre><pre><code class="python">row_sums</code></pre><pre><code>array([[5923],       [6742],       [5958],       [6131],       [5842],       [5421],       [5918],       [6265],       [5851],       [5949]], dtype=int64)</code></pre><pre><code class="python">np.fill_diagonal(norm_conf_mx, 0) #用零填充对角线，重新绘制结果plt.matshow(norm_conf_mx, cmap=plt.cm.gray)save_fig(&quot;confusion_matrix_errors_plot&quot;, tight_layout=False)plt.show()</code></pre><pre><code>Saving figure confusion_matrix_errors_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_109_1.png" class title="png"><p>第8列很亮说明，有许多的图片被错误的分类成8了，但第8行不那么差，实际上数字8 被正确分为了8</p><pre><code class="python">cl_a, cl_b = 3, 5X_aa = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_a)]X_ab = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_b)]X_ba = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_a)]X_bb = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_b)]plt.figure(figsize=(8,8))plt.subplot(221); plot_digits(X_aa[:25], images_per_row=5)plt.subplot(222); plot_digits(X_ab[:25], images_per_row=5)plt.subplot(223); plot_digits(X_ba[:25], images_per_row=5)plt.subplot(224); plot_digits(X_bb[:25], images_per_row=5)save_fig(&quot;error_analysis_digits_plot&quot;)plt.show()</code></pre><pre><code>Saving figure error_analysis_digits_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_111_1.png" class title="png"><h1 id="Multilabel-classification-多标签分类"><a href="#Multilabel-classification-多标签分类" class="headerlink" title="Multilabel classification 多标签分类"></a>Multilabel classification 多标签分类</h1><pre><code class="python">from sklearn.neighbors import KNeighborsClassifiery_train_large = (y_train &gt;= 7) #是否是大数y_train_odd = (y_train % 2 == 1)#是否是奇数y_multilabel = np.c_[y_train_large, y_train_odd]knn_clf = KNeighborsClassifier()knn_clf.fit(X_train, y_multilabel)</code></pre><pre><code>KNeighborsClassifier()</code></pre><pre><code class="python">y_multilabel</code></pre><pre><code>array([[False,  True],       [False, False],       [False, False],       ...,       [False,  True],       [False, False],       [ True, False]])</code></pre><pre><code class="python">knn_clf.predict([some_digit]) #不是大数，是奇数</code></pre><pre><code>array([[False,  True]])</code></pre><p><strong>Warning</strong>: the following cell may take a very long time (possibly hours depending on your hardware).</p><p>下面的计算单元可能需要很长时间(可能需要几个小时，这取决于您的硬件)。</p><pre><code class="python">y_train_knn_pred = cross_val_predict(knn_clf, X_train, y_multilabel, cv=3)f1_score(y_multilabel, y_train_knn_pred, average=&quot;macro&quot;)</code></pre><pre><code>0.976410265560605</code></pre><h1 id="Multioutput-多输出分类"><a href="#Multioutput-多输出分类" class="headerlink" title="Multioutput  多输出分类"></a>Multioutput  多输出分类</h1><pre><code class="python">noise = np.random.randint(0, 100, (len(X_train), 784))X_train_mod = X_train + noisenoise = np.random.randint(0, 100, (len(X_test), 784))X_test_mod = X_test + noisey_train_mod = X_trainy_test_mod = X_test</code></pre><pre><code class="python">some_index = 0plt.subplot(121); plot_digit(X_test_mod[some_index])plt.subplot(122); plot_digit(y_test_mod[some_index])save_fig(&quot;noisy_digit_example_plot&quot;)plt.show()</code></pre><pre><code>Saving figure noisy_digit_example_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_120_1.png" class title="png"><p>使用Numpy的randint()函数为MNIST图片的像素争强 左边是有噪声的，右边是干净的</p><p>通过训练分类器，清洗这张图片。</p><pre><code class="python">knn_clf.fit(X_train_mod, y_train_mod)clean_digit = knn_clf.predict([X_test_mod[some_index]])plot_digit(clean_digit)save_fig(&quot;cleaned_digit_example_plot&quot;)</code></pre><pre><code>Saving figure cleaned_digit_example_plot</code></pre><img src="/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%B1%BB/output_122_1.png" class title="png"><p>书籍：深度学习四大名著之《机器学习实战：基于Scikit-Learn、Keras和TensorFlow》第二版</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 机器学习实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 基础</title>
      <link href="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java跨平台原理"><a href="#Java跨平台原理" class="headerlink" title="Java跨平台原理"></a>Java跨平台原理</h1><p>平台：操作系统平台</p><p>跨平台：可以在任意操作系统上运行</p><p>跨平台原理： 在需要运行Java的虚拟机上安装对应的Java虚拟机JVM</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211004204743072.png" class title="image-20211004204743072"><h1 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h1><p>JRE （JavaRuntime Environment）Java程序运行时的程序</p><p>JDK （Java Development Kit) Java 开发工具包 包含JRE和开发人员使用的工具</p><p>编译工具：javac.exe 运行工具：java.exe</p> <img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211004205208635.png" class title="image-20211004205208635"><p>只需要JDK就可以运行Java程序</p><p>JDK的下载和安装</p><p>下载网站：<a href="http://www.oracle.com/">www.oracle.com</a></p><p>JDK安装：建议安装路径不带空格和中文，所有的开发工具最好安装目录同一</p><p>安装流程：略</p><p>JDK的安装目录</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211004213448697.png" class title="image-20211004213448697"><h1 id="常用的Dos命令"><a href="#常用的Dos命令" class="headerlink" title="常用的Dos命令"></a>常用的Dos命令</h1><p>1.打开cmd</p><p>常用命令</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211004213634294.png" class title="image-20211004213634294"><p>path环境变量配置</p><p>略</p><p>HelloWorld案例</p><p>HelloWorld.java</p><pre><code class="java">public class HelloWorld&#123;    public static void main(String[] args)&#123;        System.out.println(&quot;HelloWorld&quot;);    &#125;&#125;</code></pre><h1 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h1><p>编译： javac 文件名.java e.g:javac HelloWorld.java</p><p>执行： java 类名   e.g:java HelloWorld</p><p>常见问题</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><pre><code class="java">//单行注释/*多行注释*//**文档注释*/</code></pre><p>关键字</p><p>java中有特殊含义的单词</p><p>关键字的特点</p><ol><li>全是小写</li><li>在编译器中关键字有高亮显示</li></ol><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><pre><code class="java">/***/</code></pre><h2 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h2><pre><code class="java">/** @ param 变量注释* @return 描述* @throws 类描述*/</code></pre><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>一个值时固定不变的就是常量</p><p>利用关键字final指示常量</p><pre><code class="java">final double CL = 2.22</code></pre><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211004232218430.png" class title="image-20211004232218430"><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005162047637.png" class title="image-20211005162047637"><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005162157373.png" class title="image-20211005162157373"> <img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005162314419.png" class title="image-20211005162314419"><p>整数默认为int,浮点数默认为double</p><p>变量</p><p>格式：数据类型 变量名 &#x3D; 变量值</p><pre><code class="java">int a = 10;</code></pre><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005163417930.png" class title="image-20211005163417930"><p>类型转换</p><ol><li>自动类型转换</li><li>强制类型转换</li></ol><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005163542707.png" class title="image-20211005163542707"><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005163611233.png" class title="image-20211005163611233"><p>算数运算符</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005163729106.png" class title="image-20211005163729106"><p>字符+操作</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005163832958.png" class title="image-20211005163832958"><p>字符串+操作</p><pre><code>&quot;A&quot;+&quot;B&quot;=&gt;&quot;AB&quot; //字符拼接&quot;A&quot;+6=&gt;&quot;A6&quot;&quot;A&quot;+6+6=&gt;&quot;A66&quot;1+6+&quot;A&quot;=&gt;&quot;7A&quot;</code></pre><h1 id="赋值运算符号"><a href="#赋值运算符号" class="headerlink" title="赋值运算符号"></a>赋值运算符号</h1><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005164330242.png" class title="image-20211005164330242"><p>自增自减</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005164353837.png" class title="image-20211005164353837"><p>关系运算符</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005164413885.png" class title="image-20211005164413885"><p>逻辑运算符</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005164439508.png" class title="image-20211005164439508"><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005164508367.png" class title="image-20211005164508367"><p>短路逻辑运算符</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005164551924.png" class title="image-20211005164551924"><p>三元运算符</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005164611028.png" class title="image-20211005164611028"><h1 id="数据输入输出"><a href="#数据输入输出" class="headerlink" title="数据输入输出"></a>数据输入输出</h1><p>Println：可以打印出字符串，和变量； Printf：只可以打印出格式化的字符串,可以输出字符串类型的变量，不可以输出整形变量和整形； 也就是说，当需要格式化输出信息时一般选择 Printf，其他时候用 Println 就可以了</p><p>scanner类</p><pre><code class="java">//导入import java.util.Scanner;//或者 import java.util.*//创建对象Scanner sc = new Scanner(System.in);//接收数据int i = sc.nextInt();//整型String name = sc.nextLine();//输入一行String firstName = sc.next();//读取一个单词 空格作为分隔符double n = sc.nextDouble();//读取并转换下一个表示浮点数的字符序列//检测是否还有其他boolean hasNext();boolean hasNextInt();boolean hasNextDouble();</code></pre><p>格式化输出</p><pre><code class="java">System.out.printf(&quot;%8.2f&quot;,x);</code></pre><h1 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h1><p>想要对文件进行读取，就需要一个用File对象构造一个Scanner对象</p><p>如：</p><pre><code class="java">Scanner in = new Scanner(Path.get(&quot;myfile.txt&quot;),&quot;UTF-8&quot;);</code></pre><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ol><li>顺序结构</li><li>分支结构</li><li>循环结构</li></ol><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p>​if语句1</p><pre><code class="java">//格式if(关系表达式)&#123;    语句体;&#125;</code></pre><p>​if语句2</p><pre><code class="java">//格式if(关系表达式)&#123;    语句体1;&#125;else&#123;    语句体2;&#125;</code></pre><p>if语句3</p><pre><code class="java">//格式if(关系表达式)&#123;    语句体;&#125;else if&#123;    语句体;&#125;else&#123;    语句体;&#125;</code></pre><p>switch语句</p><pre><code class="java">//格式switch(表达式)&#123;        case 值1;            语句1;            break;        ...        default:&#125;</code></pre><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005170759537.png" class title="image-20211005170759537"><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211005170859776.png" class title="image-20211005170859776"><p>for循环</p><pre><code class="java">//格式for(初始化语句;条件判断语句;条件控制语句)&#123;    循环体语句;&#125;</code></pre><p>while循环</p><pre><code class="java">while(条件判断语句)&#123;    循环体语句;&#125;</code></pre><p>do…while循环</p><pre><code class="java">do&#123;    循环体语句;&#125;while(判断条件);</code></pre><p>跳转控制语句</p><pre><code class="java">continue; //跳过一次break;//结束循环</code></pre><p>Random</p><p>作用：产生随机数</p><p>步骤：</p><pre><code class="java">//导入import java.util.Random;//创建对象Random r = new Randon();int number = r.nextInt(10);//获取范围为[0,10)</code></pre><p>IDEA快捷键</p><p>psvm 回车 快速生成main()</p><p>sout 回车 快速生成输出语句</p><p>Ctrl+Alt+space 内容提示，代码补全</p><p>Ctrl+&#x2F; 单行注释 再按一次取消</p><p>Ctrl+Shift+&#x2F; 多行注释 再按一次取消</p><p>Ctrl+Alt+L 格式化</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组定义格式"><a href="#数组定义格式" class="headerlink" title="数组定义格式"></a>数组定义格式</h2><p>格式类型一：数据类型[] 变量名 int[] arr</p><p>定义了一个int类型的数组，数组名是arr</p><p>格式类型二：数据类型 变量名[]  int arr[]</p><p>定义了一个int类型的变量，变量名是arr数组</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><ol><li>动态初始化：初始化时只指定数组长度，由系统为数组分配初始值</li></ol><p>格式：数据类型[] 变量名 &#x3D; new 数据类型[数据长度]</p><p>范例： int[] arr &#x3D; new int[3]</p><p>数组元素访问</p><ol><li>数组变量访问方式</li></ol><p>格式：数组名</p><ol start="2"><li>数组内部保存的数据的访问方式</li></ol><p>格式：数组名[索引]</p><p>内存分配</p><p>JAVA中的内存分配</p><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211015230318961.png" class title="image-20211015230318961"><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211015230524624.png" class title="image-20211015230524624"><img src="/2021/10/04/JAVA-%E5%9F%BA%E7%A1%80/image-20211015231246241.png" class title="image-20211015231246241"><p>栈内存：存储局部变量</p><p>堆内存：内存new出来的实体内容（实体、对象）</p><p>单个数组的内存图</p><ol start="2"><li>静态初始化</li></ol><p>格式：数据类型[] 变量名 &#x3D; new 数据类型[]{数据1,数据2,数据3…};</p><p>范例：int[] arr &#x3D; new int[]{1,2,3};</p><p>简化格式：数据类型[] 变量名 &#x3D; {数据1,数据2,数据3…}; </p><p>范例：int[] arr &#x3D; {1,2,3};</p><p>数组操作的两个小问题</p><ol><li>索引越界</li><li>空指针异常</li></ol><h2 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h2><ol><li><p>遍历</p><pre><code class="java">//第一种for(int x = 0;x&lt;5;x++)&#123;    System.out.println(arr[x]);&#125;//第二种（arr.lenght获取数组的元素）for(int x = 0;x&lt;arr.lenght;x++)&#123;    System.out.println(arr[x]);&#125;</code></pre></li><li><p>获取最值</p><p>for 循环 一个一个比较</p></li><li><p>for each循环</p><p>for (variable:collection) statement</p><pre><code class="java">for(int element:a)    System.out.println(element);</code></pre></li><li><p>数组的拷贝</p><p>将一个数组变量拷贝给另一个数组变量，这时两个变量将引用同一个数组</p><pre><code class="java">int[] luckyNumber = smallPrimes;luckyNumber[5] = 12; // now smallPrimes[5] is also 12</code></pre></li><li><p>将数组的所有值拷贝到一个新的数组去</p><pre><code class="java">int[] CPluckyNumber = Arrays.copyOf(luckyNumbers,luckyNumber.lenght);//第二个参数为新的数组的大小</code></pre></li><li><p>数组排序</p><pre><code class="java">Arrays.sort(a);</code></pre></li></ol><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>定义</p><pre><code class="java">double[][] b;b = new double[N][N];//初始化</code></pre><h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><pre><code class="java">Math.sqrt(); //平方根Math.pow(); //平方//三角函数Math.sin();Math.cos();Math.tan();Math.atan();Math.atan2();//指数函数和对数函数Math.exp();Math.log();Math.log10();//PI 和 E常见的近似值Math.PIMath.E</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><pre><code class="java">String e = &quot;&quot;; // an empty stringString greeting = &quot;Hello&quot;;//子串String greeting = &quot;Hello&quot;;String s = greeting.substring(0,3);//s = &#39;Hel&#39;//拼接String s = s1+s2;String all = String.join(&#39;/&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);//all = 1/2/3</code></pre><p>String 为不可变字符串，但可以重新引用另一个字符串</p><p>Java字符串大致类似于char*指针，并不像C是字符型数组</p><h2 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h2><pre><code class="java">s.equals(t);//如果字符串s和字符串t相等，则返回true，否则，返回false//s和t可以是字符串变量，也可以是字符串字面量&quot;Hello&quot;.equals(greeting);&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;);</code></pre><h2 id="空串与Null串"><a href="#空串与Null串" class="headerlink" title="空串与Null串"></a>空串与Null串</h2><pre><code class="java">//判断是否为空串if(str.length()==0)if(str.equals(&quot;&quot;))//判断是否为Null串if(str==null)//既不是空串也不是null串if(str != null &amp;&amp; str.lenght() != 0)</code></pre><h2 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h2><pre><code class="java">greeting.charAt(n);//获取第n的代码单元//得到第i个码点index = greeting.offsetByCodePoints(0,i);cp = greeting.codePointAt(index);</code></pre><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类class 是构造对象的模板或蓝图</p><p>类构造（construct）对象的过程称为创建类的实例</p><p>封装（encapsulation，有时称为数据隐蔽），从形式上看封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方法。</p><p>对象中的数据称为<strong>实例域</strong>（instance field），操纵数据的过程称为<strong>方法</strong>（method）</p><p>通过一个类来建立另一个类的过程称作<strong>继承</strong>（inheritance）</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象的三个主要特征</p><ul><li>对象的行为（behavior）– 可以对对象施加哪些操作 或可以对对象施加哪些方法</li><li>对象的状态（state）– 当施加那些方法时，对象应该如何响应</li><li>对象标识（identity）– 如何辨别具有相同行为与状态的不同对象</li></ul><p>每个对象都有一个唯一的身份（identity）</p><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>依赖</p><p>聚合</p><p>继承</p><h2 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h2><p>在Java程序中，使用构造器（constructor）构造新的实例。构造器是一种特殊的方法。</p><pre><code>Date birthday = new Date();</code></pre><h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><pre><code class="java">class ClassName&#123;    field1;    field2;    ...;    constructor1;    constructor2;    ...;    method1;    method2;    ...;&#125;</code></pre><p>E.g.</p><pre><code class="java">class Employee&#123;    private String name;    private double salary;    private LocalDate hireDay;        public Employee (...)    &#123;        name = n;        salary = s;        ...    &#125;        public String getName()    &#123;        return name;    &#125;    ...&#125;</code></pre><h2 id="静态域与静态方法-⭐"><a href="#静态域与静态方法-⭐" class="headerlink" title="静态域与静态方法 ⭐"></a>静态域与静态方法 ⭐</h2><h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>有些类有多个构造器 </p><p>E.g.</p><pre><code class="java">StringBuiler massages = new StringBuilder();//构造空的对象StringBuiler massages = new StringBuilder(&quot;111&quot;);//有的可以指定字符串</code></pre><h3 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h3><p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋予默认值。</p><h3 id="无参数地构造器"><a href="#无参数地构造器" class="headerlink" title="无参数地构造器"></a>无参数地构造器</h3><p>无参数，赋予默认值</p><pre><code class="java">public Employee&#123;    name=&quot;xiaoming&quot;;    salary = 100;    hireDay = LocalDate.now();&#125;</code></pre><h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><pre><code class="java">class Employee&#123;    private static int nextId;        private int id;    //初始化块    &#123;        id = nextId;        nextId++;    &#125;&#125;</code></pre><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>Java允许使用包package将类组织起来</p><h2 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h2><pre><code class="java">import java.util.*;</code></pre><h2 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h2><pre><code>package com.horstmann.corejava;</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h2><p>由继承Employee类来定义Manager 类     extends 表示继承</p><pre><code class="java">public class Manager extends Employee&#123;//添加方法和域&#125;</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>子类的对象可以赋给超类变量</p><p>超累的引用不能赋给子类变量</p><p>E.g.</p><pre><code class="java">Employee e;e = new Manager(...);//下列情况就不行Manager m;m= new Employee(...); //不行</code></pre><h2 id="Final类"><a href="#Final类" class="headerlink" title="Final类"></a>Final类</h2><p>不允许扩展的类被称为final类</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>包含一个或多个抽象方法的类本身必须被声明为抽象的</p><h2 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h2><pre><code class="java">ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();//在JavaSE7中可以省略右边的类型参数ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;();</code></pre><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><pre><code>try&#123;    statements that might throwsexceptions&#125;catch (Exception e)&#123;    handler action&#125;</code></pre><h1 id="接口、lambda表达式与内部类"><a href="#接口、lambda表达式与内部类" class="headerlink" title="接口、lambda表达式与内部类"></a>接口、lambda表达式与内部类</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib+Numpy+Pandas 笔记（数据分析）</title>
      <link href="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/"/>
      <url>/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><h2 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h2><p>axis轴指的是x或y轴</p><p>绘制每隔两个小时的气温</p><pre><code class="python">from matplotlib import pyplot as plt #导入绘图工具x = range(2,26,2)y = [15,13,14.5,17,20,25,26,26,24,22,18,15]plt.plot(x,y) #传入x和y，通过plot绘制折线图plt.show() #在执行程序的时候展示图形</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_3_0.png" class title="png"><p>​    </p><pre><code class="python"></code></pre><pre><code class="python">from matplotlib import pyplot as plt #导入绘图工具#############################################fig = plt.figure(figsize=(20,8),dpi = 80)#设置图片大小 宽20 高8 dpi为每英寸上点的个数#############################################x = range(2,26,2)y = [15,13,14.5,17,20,25,26,26,24,22,18,15]plt.plot(x,y) #传入x和y，通过plot绘制折线图plt.show() #在执行程序的时候展示图形</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_5_0.png" class title="png"><p>​    </p><pre><code class="python">from matplotlib import pyplot as plt #导入绘图工具fig = plt.figure(figsize=(20,8),dpi = 80)#设置图片大小 宽20 高8 dpi为每英寸上点的个数x = range(2,26,2)y = [15,13,14.5,17,20,25,26,26,24,22,18,15]plt.plot(x,y) #传入x和y，通过plot绘制折线图####################################plt.savefig(&quot;./t1.png&quot;) #保存图片 可以保存为svg这种矢量图，放大不会有锯齿####################################</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_6_0.png" class title="png"><p>​    </p><pre><code class="python">from matplotlib import pyplot as plt #导入绘图工具fig = plt.figure(figsize=(20,8),dpi = 80)#设置图片大小 宽20 高8 dpi为每英寸上点的个数x = range(2,26,2)y = [15,13,14.5,17,20,25,26,26,24,22,18,15]plt.plot(x,y) #传入x和y，通过plot绘制折线图########################plt.xticks(x)#设置x轴的刻度#plt.yticks() 调整y轴刻度 ########################plt.show() #在执行程序的时候展示图形 </code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_7_0.png" class title="png"><p>​    </p><pre><code class="python"></code></pre><pre><code class="python">#绘制10点到12点每分钟的气温折线图from matplotlib import pyplot as pltimport randomplt.figure(figsize=(20,10),dpi=80)x = range(0,120)y = [random.randint(20,35) for i in range(120)]#plt.xticks(x)plt.plot(x,y)plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_9_0.png" class title="png"><p>​    </p><pre><code class="python">#绘制10点到12点每分钟的气温折线图  调整x轴刻度，显示字符串from matplotlib import pyplot as pltimport randomplt.figure(figsize=(20,10),dpi=80)x = range(0,120)y = [random.randint(20,35) for i in range(120)]#调整x轴刻度_x = list(x)_xtick_labels = [&quot;10:&#123;&#125;&quot;.format(i) for i in range(60)]_xtick_labels += [&quot;11:&#123;&#125;&quot;.format(i) for i in range(60)]plt.xticks(_x[::10],_xtick_labels[::10],rotation = 45) #取步长和数据一一对应 rotation旋转plt.plot(x,y)plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_10_0.png" class title="png"><p>​    </p><pre><code class="python">#绘制10点到12点每分钟的气温折线图  设置中文字体from matplotlib import pyplot as pltimport randomimport matplotlib#设置字体font = &#123;    &#39;family&#39;:&#39;MicroSoft YaHei&#39;,    &#39;weight&#39;:&#39;bold&#39;,    &#39;size&#39;:&#39;10&#39;&#125;matplotlib.rc(&quot;font&quot;,**font)#######################################plt.figure(figsize=(20,10),dpi=80)x = range(0,120)y = [random.randint(20,35) for i in range(120)]_x = list(x)_xtick_labels = [&quot;10时&#123;&#125;分&quot;.format(i) for i in range(60)]_xtick_labels += [&quot;11时&#123;&#125;分&quot;.format(i) for i in range(60)]plt.xticks(_x[::10],_xtick_labels[::10],rotation = 45) #取步长和数据一一对应 rotation旋转 plt.plot(x,y)plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_11_0.png" class title="png"><p>​    </p><pre><code class="python">#在图上添加描述信息from matplotlib import pyplot as pltimport randomimport matplotlibfont = &#123;    &#39;family&#39;:&#39;MicroSoft YaHei&#39;,    &#39;weight&#39;:&#39;bold&#39;,    &#39;size&#39;:&#39;20&#39;&#125;matplotlib.rc(&quot;font&quot;,**font)plt.figure(figsize=(20,10),dpi=80)x = range(0,120)y = [random.randint(20,35) for i in range(120)]_x = list(x)_xtick_labels = [&quot;10时&#123;&#125;分&quot;.format(i) for i in range(60)]_xtick_labels += [&quot;11时&#123;&#125;分&quot;.format(i) for i in range(60)]plt.xticks(_x[::10],_xtick_labels[::10],rotation = 45) #取步长和数据一一对应 rotation旋转plt.plot(x,y)#添加描述信息plt.xlabel(&quot;时间&quot;)plt.ylabel(&quot;温度 单位（℃）&quot;)plt.title(&quot;10点到12点每分钟气温变化情况&quot;)plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_12_0.png" class title="png"><p>​    </p><pre><code class="python">#在图上绘制网格from matplotlib import pyplot as pltimport randomimport matplotlibfont = &#123;    &#39;family&#39;:&#39;MicroSoft YaHei&#39;,    &#39;weight&#39;:&#39;bold&#39;,    &#39;size&#39;:&#39;20&#39;&#125;matplotlib.rc(&quot;font&quot;,**font)plt.figure(figsize=(20,10),dpi=80)x = range(0,120)y = [random.randint(20,35) for i in range(120)]_x = list(x)_xtick_labels = [&quot;10时&#123;&#125;分&quot;.format(i) for i in range(60)]_xtick_labels += [&quot;11时&#123;&#125;分&quot;.format(i) for i in range(60)]plt.xticks(_x[::5],_xtick_labels[::5],rotation = 45) #取步长和数据一一对应 rotation旋转plt.plot(x,y)plt.xlabel(&quot;时间&quot;)plt.ylabel(&quot;温度 单位（℃）&quot;)plt.title(&quot;10点到12点每分钟气温变化情况&quot;)#绘制网格plt.grid()#根据刻度画#alpha设置透明度 数值0-1# plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_13_0.png" class title="png"><p>​    </p><pre><code class="python">#绘制两条折现from matplotlib import pyplot as pltimport randomimport matplotlib as mplfont = &#123;    &quot;family&quot;:&quot;MicroSoft YaHei&quot;,    &quot;weight&quot;:&quot;bold&quot;,    &quot;size&quot;:&quot;10&quot;&#125;mpl.rc(&quot;font&quot;,**font)x = range(1,11)y1 = [random.randint(3,9) for i in x]y2 = [random.randint(3,9) for i in x]#添加折线的标签、颜色、样式plt.plot(x,y1,label = &quot;用户A&quot;,color=&quot;blue&quot;,linestyle = &#39;:&#39;)plt.plot(x,y2,label = &quot;用户B&quot;,color=&quot;red&quot;,linestyle = &#39;-.&#39;)&#39;&#39;&#39;color 线条颜色linestyle 线条风格linewidth 线条粗细alpha 线条透明度&#39;&#39;&#39;#添加图例plt.legend()plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_14_0.png" class title="png"><p>​    </p><pre><code class="python">#绘制两条折现from matplotlib import pyplot as pltimport randomimport numpy as npimport matplotlib as mplfont = &#123;    &quot;family&quot;:&quot;MicroSoft YaHei&quot;,    &quot;weight&quot;:&quot;bold&quot;,    &quot;size&quot;:&quot;10&quot;&#125;mpl.rc(&quot;font&quot;,**font)x = range(0,11)y1 = [random.randint(0,2000) for i in x]y2 = [random.randint(0,2000) for i in x]_y1 = np.array(y1)_y2 = np.array(y2)#获取最大最小值x_y1_max = np.argmax(_y1)x_y1_min = np.argmin(_y1)x_y2_max = np.argmax(_y2)x_y2_min = np.argmin(_y2)plt.plot(x,y1,label = &quot;用户A&quot;,color=&quot;blue&quot;)plt.plot(x,y2,label = &quot;用户B&quot;,color=&quot;red&quot;)#绘制最高点和最低点plt.plot(x_y1_min,_y1[x_y1_min],&#39;go&#39;) plt.plot(x_y1_max,_y1[x_y1_max],&#39;go&#39;)plt.plot(x_y2_min,_y2[x_y2_min],&#39;gs&#39;) plt.plot(x_y2_max,_y2[x_y2_max],&#39;gs&#39;)plt.legend()#绘制水印plt.text(x=6,y=100,s=&quot;ZZH&quot;,fontsize=50,color = &quot;gray&quot;,alpha = 0.2)plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_15_0.png" class title="png"><p>​    </p><h2 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h2><pre><code class="python">import randoma = [random.randint(24,35) for i in range(0,15)]b = [random.randint(24,35) for i in range(0,15)]print(a)print(b)</code></pre><pre><code>[28, 29, 24, 32, 27, 25, 31, 33, 28, 31, 28, 33, 34, 24, 27][33, 34, 27, 27, 31, 29, 31, 30, 34, 26, 26, 31, 30, 29, 29]</code></pre><pre><code class="python">from matplotlib import pyplot as pltx=range(0,15)plt.scatter(x,a) #绘制散点图 plt.scatter(x,b)  </code></pre><pre><code>&lt;matplotlib.collections.PathCollection at 0x1f409bba888&gt;</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_18_1.png" class title="png"><p>​    </p><h2 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h2><pre><code class="python">import randomc = [random.randint(0,1000) for i in range(0,15)]print(c)</code></pre><pre><code>[90, 924, 412, 993, 665, 629, 723, 550, 852, 500, 947, 153, 787, 586, 606][496, 545, 952, 78, 446, 815, 526, 395, 757, 386, 261, 84, 614, 980, 13]</code></pre><pre><code class="python">from matplotlib import pyplot as pltx = range(0,15)plt.bar(x,c,color = &quot;orange&quot;,width=0.3) #绘制条形图</code></pre><pre><code>&lt;BarContainer object of 15 artists&gt;</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_21_1.png" class title="png"><p>​    </p><pre><code class="python">from matplotlib import pyplot as pltx = range(0,15)plt.barh(x,c,height=0.3,color = &quot;orange&quot;) #绘制横向条形图</code></pre><pre><code>&lt;BarContainer object of 15 artists&gt;</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_22_1.png" class title="png"><p>​    </p><pre><code class="python">a = [&quot;猩球崛起2&quot;,&quot;敦刻尔克&quot;,&quot;蜘蛛侠&quot;,&quot;战狼2&quot;]b_16 = [15746,321,4497,319]b_15 = [12357,156,2045,168]b_14 = [2358,399,2358,362]</code></pre><pre><code class="python">#绘制多次条形图from matplotlib import pyplot as pltbar_width = 0.1x_14 = list(range(len(a)))x_15 = [i+bar_width for i in x_14]x_16 = [i+bar_width for i in x_15]plt.bar(range(len(a)),b_14,width = bar_width,label = &quot;14日&quot;,color = &quot;cyan&quot;)plt.bar(x_15,b_15,width=bar_width,label = &quot;15日&quot;)plt.bar(x_16,b_16,width=bar_width,label = &quot;16日&quot;)plt.legend()plt.xticks(x_15,a)plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_24_0.png" class title="png"><p>​    </p><h2 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h2><pre><code class="python">import randoma = [random.randint(30,151) for i in range(0,250)]len(a)</code></pre><pre><code>250</code></pre><pre><code class="python">from matplotlib import pyplot as plt#计算组数d=11 #组距num_bins = (max(a)-min(a))//dplt.figure(figsize=(20,8),dpi=80)plt.hist(a,num_bins)#分组#设置x轴刻度plt.xticks(range(min(a),max(a)+d,d)) plt.grid()plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_27_0.png" class title="png"><p>​    </p><pre><code class="python">from matplotlib import pyplot as plt#计算组数d=11 #组距num_bins = (max(a)-min(a))//dplt.figure(figsize=(20,8),dpi=80)plt.hist(a,num_bins,density = 1)#频率分布直方图#设置x轴刻度plt.xticks(range(min(a),max(a)+d,d)) plt.grid()plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_28_0.png" class title="png"><p>​    </p><pre><code class="python">interval =[0,5,10,15,20,25,30,35,40,45,60,90]width = [5,5,5,5,5,5,5,5,5,15,30,60]quantity = [836,2737,3723,3926,3596,1438,3273,642,824,613,215,47] #这些统计之后的数据是不能绘制直方图的#通常来说能够使用plt.hist方法的是那些没用统计过的数据</code></pre><pre><code class="python">from matplotlib import pyplot as pltinterval =[0,5,10,15,20,25,30,35,40,45,60,90]width = [5,5,5,5,5,5,5,5,5,15,30,60] #组距quantity = [836,2737,3723,3926,3596,1438,3273,642,824,613,215,47]plt.figure(figsize=(20,8),dpi=80)plt.bar(range(len(quantity)),quantity,width =1)#设置_x = [i-0.5 for i in range(13)]_xtick_labels = interval+[150]plt.xticks(_x,_xtick_labels)plt.grid()plt.show()</code></pre><p>​    </p><img src="/2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/output_30_0.png" class title="png"><p>​    </p><h2 id="更多绘图工具了解"><a href="#更多绘图工具了解" class="headerlink" title="更多绘图工具了解"></a>更多绘图工具了解</h2><p>matplotlib支持的图形样式</p><p><a href="http://matplotlib.org/gallery/index.html">http://matplotlib.org/gallery/index.html</a></p><p><a href="https://matplotlib.org/stable/gallery/index.html">https://matplotlib.org/stable/gallery/index.html</a></p><p>其他的画图工具：</p><p>百度ECharts</p><p>plotly <a href="http://plot.ly/python">http://plot.ly/python</a></p><p>seaborn </p><h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>快速 方便 科学计算的基础库</p><p>用在大型和多维数组上执行数值运算</p><pre><code class="python">import numpy as npt1 = np.array([1,2,3,4,5,6,7,8,9,10])print(t1)t2 = np.array(range(10))print(t2)t3 = np.arange(10)print(t3)t3.dtype#显示np中存放的类型</code></pre><pre><code>[ 1  2  3  4  5  6  7  8  9 10][0 1 2 3 4 5 6 7 8 9][0 1 2 3 4 5 6 7 8 9]dtype(&#39;int32&#39;)</code></pre><pre><code class="python">t4 = np.array(range(1,4),dtype = float) #定义存储的类型t4.dtype</code></pre><pre><code>dtype(&#39;float64&#39;)</code></pre><pre><code class="python">t5 = np.array([1,0,0,1,0,0,],dtype = bool)print(t5)</code></pre><pre><code>[ True False False  True False False]</code></pre><pre><code class="python">t6 = t5.astype(&quot;int8&quot;) #t5转化成int类型print(t6)</code></pre><pre><code>[1 0 0 1 0 0]</code></pre><pre><code class="python">#np中的小数t7 = np.array([random.random() for i in range(0,10)])print(t7)print(t7.dtype)t8 = np.round(t7,2) #取两位小数print(t8)</code></pre><pre><code>[0.01291171 0.50694144 0.81280042 0.95928213 0.56136455 0.51815879 0.64365885 0.59195829 0.11904834 0.80636463]float64[0.01 0.51 0.81 0.96 0.56 0.52 0.64 0.59 0.12 0.81]</code></pre><h2 id="数组的计算"><a href="#数组的计算" class="headerlink" title="数组的计算"></a>数组的计算</h2><pre><code class="python">import numpy as npt1 = np.arange(12)print(t1.shape)t1.reshape(3,4)#将t1变成3*4的数组</code></pre><pre><code>(12,)array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><pre><code class="python">t2 = np.arange(24).reshape(2,3,4)t2</code></pre><pre><code>array([[[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[12, 13, 14, 15],        [16, 17, 18, 19],        [20, 21, 22, 23]]])</code></pre><pre><code class="python">t2.flatten() #将数组展开成一维的</code></pre><pre><code>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,       17, 18, 19, 20, 21, 22, 23])</code></pre><pre><code class="python">t3 = t1.reshape(3,4)print(t3.transpose()) #转置的3种方法print(t3.T)print(t3.swapaxes(1,0)) #交换轴 也可以形成转置的效果</code></pre><pre><code>[[ 0  4  8] [ 1  5  9] [ 2  6 10] [ 3  7 11]][[ 0  4  8] [ 1  5  9] [ 2  6 10] [ 3  7 11]][[ 0  4  8] [ 1  5  9] [ 2  6 10] [ 3  7 11]]</code></pre><h3 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h3><pre><code class="python">print(t2+2) #每个数都加2 广播性质</code></pre><pre><code>[[[ 2  3  4  5]  [ 6  7  8  9]  [10 11 12 13]] [[14 15 16 17]  [18 19 20 21]  [22 23 24 25]]]</code></pre><pre><code class="python">t3 = np.arange(100,124)t4 = np.arange(0,24)t3+t4 #位置相同上的相加</code></pre><pre><code>array([100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,       126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146])</code></pre><h3 id="numpy数组读取本地数据和索引"><a href="#numpy数组读取本地数据和索引" class="headerlink" title="numpy数组读取本地数据和索引"></a>numpy数组读取本地数据和索引</h3><p> 二维数组的轴使用0，1，2….表示。</p><pre><code class="python">np.arange(10).reshape((2,5)) #2表示0轴的长度，5表示为1轴的长度</code></pre><p>numpy读取本地数据</p><pre><code class="python">np.loadtxt(frame,dtype =np.float,delimiter=None,skiprows = 0,usecols = None,unpack=False)&quot;&quot;&quot;frame 文件、字符串、产生器 dtype 数据类型 默认np.floatdelimiter 分隔字符串，默认是任何空格skiprows 跳过前面x行 一般跳过第一行表头usecols 读取指定的列，索引，元组类型unpack (转置)如果为True,读入属性将分别写入不同数组变量。False读入数据只写入一个数组变量，默认False&quot;&quot;&quot;</code></pre><p>数组的拼接</p><pre><code class="python">t1 = np.arange(10).reshape(2,5)print(t1)print(&quot;\n&quot;)t2 = np.arange(10).reshape(2,5)print(t2)print(&quot;\n&quot;)t3 = np.vstack((t1,t2))  #竖直拼接t4 = np.hstack((t1,t2))  #水平拼接print(t3)print(&quot;\n&quot;)print(t4)print(&quot;\n&quot;)</code></pre><pre><code>[[0 1 2 3 4] [5 6 7 8 9]]</code></pre><p>​    </p><pre><code>[[0 1 2 3 4] [5 6 7 8 9]]</code></pre><p>​    </p><pre><code>[[0 1 2 3 4] [5 6 7 8 9] [0 1 2 3 4] [5 6 7 8 9]]</code></pre><p>​    </p><pre><code>[[0 1 2 3 4 0 1 2 3 4] [5 6 7 8 9 5 6 7 8 9]]</code></pre><p>​<br>​    </p><pre><code class="python">t5 = np.arange(12,24).reshape(3,4)print(t5)print(&quot;\n&quot;)t5[[1,2],:] = t5[[2,1],:] #行交换print(t5)print(&quot;\n&quot;)t5[:,[0,2]] = t5[:,[2,0]]#列交换print(t5)print(&quot;\n&quot;)</code></pre><pre><code>[[12 13 14 15] [16 17 18 19] [20 21 22 23]]</code></pre><p>​    </p><pre><code>[[12 13 14 15] [20 21 22 23] [16 17 18 19]]</code></pre><p>​    </p><pre><code>[[14 13 12 15] [22 21 20 23] [18 17 16 19]]</code></pre><p>​<br>​    </p><p>Numpy其他好方法</p><pre><code class="python">#获取最大最小值的位置np.argmax(t,axis = 0)np.argmin(t,axis = 1)#创建一个全为0的数组np.zeros((3,4))#创建一个全为1的数组np.ones((3,4))#创建一个对角线为1的正方形数组(方阵)np.eye(3)</code></pre><p>numpy中的随机方法</p><pre><code class="python">import numpy as np#加载国家信息us_add = &quot;./youtube_video_data/USvideostest.csv&quot;uk_add = &quot;./youtube_video_data/GBvideostest.csv&quot;us_data = np.loadtxt(us_add,delimiter=&quot;,&quot;,dtype = int,skiprows = 1)uk_data = np.loadtxt(uk_add,delimiter=&quot;,&quot;,dtype = int,skiprows = 1)#添加国家信息#构造全为0的数据zeros_data = np.zeros((us_data.shape[0],1)).astype(int)ones_data = np.ones((uk_data.shape[0],1)).astype(int)us_data = np.hstack((us_data,zeros_data))uk_data = np.hstack((uk_data,ones_data))#拼接两组数final_data = np.vstack((us_data,uk_data))print(final_data)</code></pre><pre><code>[[4394029  320053    5931   46245       0] [7860119  185853   26679       0       0] [5845909  576597   39774  170708       0] ... [ 170003    6592     127     454       1] [ 893125   44811     652    2056       1] [1474925   58532    3223   14396       1]]</code></pre><pre><code class="python">#numpy生成随机数import numpy as npnp.random.rand(2,3) #创建d0-dn维度的均匀分布的随机数数组，浮点数，范围0-1np.random.randn(2,3) #创建d0-dn维度的标准正太分布随机数，浮点数，平均数0 标准差为1np.random.randint(low,high,(shape)) #从给定上下限范围选取随机数整数，范围为low-high 形状是shapenp.random.uniform(low,high,(size))#产生具有均匀分布的数组。low为起始值，high为结束值 size为形状np.random.normal(lic,scale,(size)) #从指定正太分布中随机抽取样本，分布中心是loc（概率分布的平均值），标准差是scale 形状sizenp.random.seed(s) #随机种子，s是给定的种子数。因为计算机生成的是伪随机数，所以通过设定相同的随机数种子，可以每次都生成相同的随机数</code></pre><pre><code>array([[-0.69278629,  1.89889183,  0.1616682 ],       [-1.38241898,  0.54585064, -0.39824509]])</code></pre><p>numpy的注意点 copy和view</p><ol><li>a&#x3D;b 完全不复制 a和b相互影响</li><li>a&#x3D;b[:] 视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的</li><li>a&#x3D;b.copy() 复制，a和b互不影响</li></ol><p>numpy中的nan和常用统计方法</p><p>nan:not a number 不是一个数字<br>两个nan是不相等的<br>判断数组中nan的数量</p><p>np.count_nonzero(t!&#x3D;t)</p><p>inf: inf正无穷 -inf负无穷 都是float类型</p><p>填充数据中的nan</p><pre><code class="python">import numpy as npdef fill_ndarray(t1):    for i in range(t1.shape[1]): #遍历，每一列        temp_col = t1[:,i]  #当前一列        nan_num = np.count_nonzero(temp_col!=temp_col)        if nan_num !=0: #不为0，说明有nan            temp_not_nan_col = temp_col[temp_col==temp_col]            temp_col[np.isnan(temp_col)] = temp_not_nan_col.mean()  #选中当前为nan的位置，值赋为不为nan的均值    return t1t1 = np.arange(12).reshape((3,4)).astype(&quot;float&quot;)t1[1,2:] = np.nan #替换成nant1 = fill_ndarray(t1)print(t1)</code></pre><pre><code>[[ 0.  1.  2.  3.] [ 4.  5.  6.  7.] [ 8.  9. 10. 11.]]</code></pre><p>numpy中常用的函数</p><pre><code class="python">t.sum(axis=None) #求和t.mean(a,axis=None) #均值np.median(t,axis=None) #中值t.max(axis=None) #最大值t.min(axis=None) #最小值np.ptp(t,axis=None) #极值t.std(axis=None) #标准差</code></pre><p>小结</p><ol><li>选择行 t[2]  t[3:,:]</li><li>选择列 t[:,4:]</li><li>连续选择行列 t[2:,:3]</li><li>不连续 t[[1,3],[2,4]] 选择的是（1，2）（3，4）两个位置的值</li><li>索引 t[2,3]<br>切片选一段 索引选一个值</li><li>赋值 t[2:,3] &#x3D; 3</li><li>bool索引 t[t&gt;10] &#x3D; 10</li><li>三元运算符 np.where(t&gt;10,20,0) 大于10的替换成20 其他替换成0</li><li>t.clip(10，20) 把小于10的替换成10 大于20的替换成20</li><li>转置 t.T t.transpose() t.swapaxes(1,0)</li><li>读取本地文件 np.loadtxt()</li><li>nan不是数字  inf无限</li></ol><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p><a href="http://www.pypandas.cn/docs/">http://www.pypandas.cn/docs/</a></p><p>高性能的数据分析工具</p><p>Series 一维数据 带标(索引)签数组</p><p>DataFrame 二维 Series容器</p><p>pandas Series创建</p><pre><code class="python">#创建Seriesimport stringimport pandas as pdimport numpy as npt = pd.Series(np.arange(10),index = list(string.ascii_uppercase[:10])) #index指定索引为A-Jprint(t)print(type(t))</code></pre><pre><code>A    0B    1C    2D    3E    4F    5G    6H    7I    8J    9dtype: int32&lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre><pre><code class="python">#通过字典创建Seriestemp_dict = &#123;&quot;name&quot;:&quot;xiaohong&quot;,&quot;age&quot;:30,&quot;tel&quot;:10086&#125;t1 = pd.Series(temp_dict)print(t1)</code></pre><pre><code>name    xiaohongage           30tel        10086dtype: object</code></pre><pre><code class="python">#字典推导式a = &#123;string.ascii_uppercase[i]:i for i in range(10)&#125;print(a)</code></pre><pre><code>&#123;&#39;A&#39;: 0, &#39;B&#39;: 1, &#39;C&#39;: 2, &#39;D&#39;: 3, &#39;E&#39;: 4, &#39;F&#39;: 5, &#39;G&#39;: 6, &#39;H&#39;: 7, &#39;I&#39;: 8, &#39;J&#39;: 9&#125;</code></pre><pre><code class="python">#Series 切片和索引print(t1[&quot;age&quot;])print(t1[0])print(t1[1:2])print(t1[[&quot;age&quot;,&quot;tel&quot;]])</code></pre><pre><code>30xiaohongage    30dtype: objectage       30tel    10086dtype: object</code></pre><pre><code class="python">t[t&lt;=4]</code></pre><pre><code>A    0B    1C    2D    3E    4dtype: int32</code></pre><pre><code class="python">print(t.index) #索引print(type(t.index))print(t.values) #数值print(type(t.values))</code></pre><pre><code>Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;], dtype=&#39;object&#39;)&lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;[0 1 2 3 4 5 6 7 8 9]&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><pre><code class="python">t.where(t&gt;5,10) #小于等于5的替换成10</code></pre><pre><code>A    10B    10C    10D    10E    10F    10G     6H     7I     8J     9dtype: int32</code></pre><p>pandas 读取外部数据</p><pre><code class="python">import pandas as pddf = pd.read_csv(&quot;./dogNames2.csv&quot;)print(df)</code></pre><pre><code>      Row_Labels  Count_AnimalName0              1                 11              2                 22          40804                 13          90201                 14          90203                 1...          ...               ...16215      37916                 116216      38282                 116217      38583                 116218      38948                 116219      39743                 1[16220 rows x 2 columns]</code></pre><pre><code class="python">#pandas DataFrame创建pd.DataFrame(np.arange(12).reshape(3,4))#行索引 表明不同行 横向索引 叫index 0轴 axis = 0 #列索引 表明不同列 纵向索引 叫columns 1轴 axis = 1</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>      <td>1</td>      <td>2</td>      <td>3</td>    </tr>    <tr>      <th>1</th>      <td>4</td>      <td>5</td>      <td>6</td>      <td>7</td>    </tr>    <tr>      <th>2</th>      <td>8</td>      <td>9</td>      <td>10</td>      <td>11</td>    </tr>  </tbody></table></div><pre><code class="python">df = pd.DataFrame(np.arange(12).reshape(3,4),index=list(&quot;ABC&quot;),columns = list(&quot;WXYZ&quot;)) #指定索引print(df)</code></pre><pre><code>   W  X   Y   ZA  0  1   2   3B  4  5   6   7C  8  9  10  11</code></pre><pre><code class="python">#DataFrame 传入字典d1 = &#123;&quot;name&quot;:[&quot;xiaohong&quot;,&quot;xiaoming&quot;],&quot;age&quot;:[23,22],&quot;tel&quot;:[110,120]&#125;pd.DataFrame(d1)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>age</th>      <th>tel</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>xiaohong</td>      <td>23</td>      <td>110</td>    </tr>    <tr>      <th>1</th>      <td>xiaoming</td>      <td>22</td>      <td>120</td>    </tr>  </tbody></table></div><pre><code class="python">d2 = [&#123;&quot;name&quot;:&quot;xiaohong&quot;,&quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;] #没有数值就是NaNpd.DataFrame(d2)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>age</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>xiaohong</td>      <td>12.0</td>    </tr>    <tr>      <th>1</th>      <td>xiaoming</td>      <td>NaN</td>    </tr>  </tbody></table></div><pre><code class="python">#DataFrame的描述信息#DataFrame的基础属性df.shape #行数 列数df.dtype #列数据类型df.ndim #数据维度df.index #行索引df.columns #列索引df.values #对象只，二维ndarray数组#DataFrame 整体情况查询df.head(3) #显示头部几行，默认5行df.tail(3) #显示末尾几行，默认5行df.info() #相关信息预览df.describe()#快速综合统计结果</code></pre><pre><code class="python">#DataFrame排序的方法 默认按列排序df.sort_values(by = &quot;按照什么排序&quot;，ascending = True)#默认升序排序ascending改为False为降序</code></pre><pre><code class="python">#pandas切片和索引df[10:20]df[10:20][&quot;Row_Labels&quot;] #取10-20行的Row_Labels这一列#pandas取行或列的注意点# - 方括号写数组，表示取行，对行进行操作# - 写字符串，表示的去列索引，对列进行操作</code></pre><pre><code class="python">#pandas LOC和ILOCdf.loc #通过标签索引行数据df.iloc #通过位置获取行数据</code></pre><h3 id="LOC"><a href="#LOC" class="headerlink" title="LOC"></a>LOC</h3><pre><code class="python">df.loc[&quot;A&quot;,&quot;X&quot;] #取某一位置的值</code></pre><pre><code>1</code></pre><pre><code class="python">df.loc[&quot;B&quot;,[&quot;W&quot;,&quot;X&quot;]] #取某两个地方的值</code></pre><pre><code>W    4X    5Name: B, dtype: int32</code></pre><pre><code class="python">#选择间隔的多行多列df.loc[[&quot;A&quot;,&quot;C&quot;],[&quot;W&quot;,&quot;Z&quot;]]</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>W</th>      <th>Z</th>    </tr>  </thead>  <tbody>    <tr>      <th>A</th>      <td>0</td>      <td>3</td>    </tr>    <tr>      <th>C</th>      <td>8</td>      <td>11</td>    </tr>  </tbody></table></div><pre><code class="python">#选择连续多行df.loc[&quot;A&quot;:&quot;B&quot;,[&quot;W&quot;,&quot;Z&quot;]]</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>W</th>      <th>Z</th>    </tr>  </thead>  <tbody>    <tr>      <th>A</th>      <td>0</td>      <td>3</td>    </tr>    <tr>      <th>B</th>      <td>4</td>      <td>7</td>    </tr>  </tbody></table></div><h3 id="ILOC"><a href="#ILOC" class="headerlink" title="ILOC"></a>ILOC</h3><pre><code class="python">df.iloc[1:3,[2,3]]</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Y</th>      <th>Z</th>    </tr>  </thead>  <tbody>    <tr>      <th>B</th>      <td>6</td>      <td>7</td>    </tr>    <tr>      <th>C</th>      <td>10</td>      <td>11</td>    </tr>  </tbody></table></div><pre><code class="python">df.iloc[1:3,1:3]</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>X</th>      <th>Y</th>    </tr>  </thead>  <tbody>    <tr>      <th>B</th>      <td>5</td>      <td>6</td>    </tr>    <tr>      <th>C</th>      <td>9</td>      <td>10</td>    </tr>  </tbody></table></div><pre><code class="python">#赋值修改数据df.loc[&quot;A&quot;,&quot;Y&quot;] = 100df.iloc[1:2,0:2] = 111print(df)</code></pre><pre><code>     W    X    Y   ZA    0    1  100   3B  111  111    6   7C    8    9   10  11</code></pre><h2 id="pandas-布尔索引"><a href="#pandas-布尔索引" class="headerlink" title="pandas 布尔索引"></a>pandas 布尔索引</h2><pre><code class="python">df[df[&quot;W&quot;]&gt;0]</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>W</th>      <th>X</th>      <th>Y</th>      <th>Z</th>    </tr>  </thead>  <tbody>    <tr>      <th>B</th>      <td>111</td>      <td>111</td>      <td>6</td>      <td>7</td>    </tr>    <tr>      <th>C</th>      <td>8</td>      <td>9</td>      <td>10</td>      <td>11</td>    </tr>  </tbody></table></div><pre><code class="python">df[(df[&quot;W&quot;]&gt;0)&amp;(df[&quot;W&quot;]&lt;10)] #两个条件   &amp;且 |或 不同条件需要用括号括起来</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>W</th>      <th>X</th>      <th>Y</th>      <th>Z</th>    </tr>  </thead>  <tbody>    <tr>      <th>C</th>      <td>8</td>      <td>9</td>      <td>10</td>      <td>11</td>    </tr>  </tbody></table></div><pre><code class="python">#函数名称 函数功能和描述lower() #将的字符串转换为小写。upper() #将的字符串转换为大写。len() #得出字符串的长度。strip() #去除字符串两边的空格（包含换行符）。split() #用指定的分割符分割字符串。cat(sep=&quot;&quot;) #用给定的分隔符连接字符串元素。get_dummies() #返回一个带有独热编码值的 DataFrame 结构。contains(pattern) #如果子字符串包含在元素中，则为每个元素返回一个布尔值 True，否则为 False。replace(a,b) #将值 a 替换为值 b。count(pattern) #返回每个字符串元素出现的次数。startswith(pattern) #如果 Series 中的元素以指定的字符串开头，则返回 True。endswith(pattern) #如果 Series 中的元素以指定的字符串结尾，则返回 True。findall(pattern) #以列表的形式返出现的字符串。swapcase() #交换大小写。islower() #返回布尔值，检查 Series 中组成每个字符串的所有字符是否都为小写。issupper() #返回布尔值，检查 Series 中组成每个字符串的所有字符是否都为大写。isnumeric() #返回布尔值，检查 Series 中组成每个字符串的所有字符是否都为数字。repeat(value) #以指定的次数重复每个元素。find(pattern) #返回字符串第一次出现的索引位置。#http://m.biancheng.net/pandas/string.html</code></pre><pre><code>  File &quot;C:\Users\Zheng\AppData\Local\Temp/ipykernel_3120/2727733356.py&quot;, line 5    strip() 去#除字符串两边的空格（包含换行符）。                ^SyntaxError: invalid syntax</code></pre><pre><code class="python">#pandas 缺失数据的处理#判断是否为NaN pd.isnull(df) pd.notnull(df)#处理方式1：删除NaN所在的行列t.dropna(axis=0,how=&quot;any&quot;,inplace = False) #how参数 any表示有任意一个NaN就删 all表示全为NaN才删 inplace参数是否进行原地修改#处理方式2：填充数据t.fillna(t.mean())t.fillna(t.median())t.fillam(0)#处理为0的数据t[t==0] = np.nan#当然不是每次为0，都需要处理#计算平均值的时候nan是不参与的，但是0会</code></pre><h3 id="pandas-统计方法"><a href="#pandas-统计方法" class="headerlink" title="pandas 统计方法"></a>pandas 统计方法</h3><pre><code class="python">#获取平均数df[&quot;某列&quot;].mean()#获取某个什么的数量len(set(df[&quot;某列&quot;].tolist()))df[&quot;某列&quot;].unique() #把每一个的唯一一个提取出来#获取演员人数temp_actors_list = df[&quot;某列&quot;].str.split(&quot;,&quot;).tolost()actors_list = [i for j in temp_actors_list for i in j]actor_num = len(set(actor_list)) #演员数量#y=max f(t) ：y是f(t)函数的最大值#y=argmax f(t) ：y是f(t)函数取到最大值时的参数tdf[].max()df[].min()df[].argmax()df[].argmin()df[].median()#中位数</code></pre><h3 id="数据合并和分组"><a href="#数据合并和分组" class="headerlink" title="数据合并和分组"></a>数据合并和分组</h3><p>如果有哪一个分类，就变成1<br><img src="undefined2021/09/19/Matplotlib-Numpy-Pandas-%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%89/attachment:%E5%9B%BE%E7%89%87.png" alt="%E5%9B%BE%E7%89%87.png"></p><pre><code class="python">#比如 电影分类那列数据为 &quot;A,B,C&quot; A,B,C代表3钟不同分类 一个电影可能有多个分类 #set()去重list = df[&quot;分类&quot;].str.split(&quot;,&quot;).to_list()#转化成list  [[][]] 列表嵌套结构genre_list = list(set([i for j in list for i in j])) #展开#构造全为0的数组zero_df = pd.DataFrame(np.zeros((df.shape[0],len(genre_list))),coulumns = genre_list)#给每个电影出现分类的电影位置赋值为1for i in range(df.shape[0]):    zeros_df.loc[i,list[i]] = 1#统计数量和genre_count = zero_df.sum(axis=0)print(genre_count)#排序genre_count.sort_values()#画图...</code></pre><pre><code class="python">#join 行索引相同的合并到一起t1.join(t2)#merge 列索引相同的合并到一起t1.merge(t2,on=&quot;在哪列操作&quot;，how=&quot;用什么方式连接&quot;)</code></pre><pre><code class="python">#分组groupdf = df.groupby(by=&quot;按某一列分组&quot;)countNum = groupdf[&quot;某一列&quot;].count() #计算某列的分类的数量countNum[&quot;某一类&quot;]#取出某一类的数量</code></pre><pre><code class="python">#DataFrameGroupBy对象的方法count #分组中非NA值得数量sum #非NA值的和mean #非NA值得平均数median #非NA值得算数中位数std、var #无偏（分母为n-1)标准差和方差min、max #非NA值得最小 最大值</code></pre><h3 id="索引和复合索引"><a href="#索引和复合索引" class="headerlink" title="索引和复合索引"></a>索引和复合索引</h3><pre><code class="python">df.index #获取indexdf.index = [&quot;x&quot;,&quot;y&quot;] #指定索引df.reindex(list(&quot;abcde&quot;))#重新设置indexdf.set_index(&quot;Country&quot;,drop=False) #指定某一列作为indexdf.set_index(&quot;Country&quot;).index.unique() #返回index的唯一值#Series复合索引df.set_index([&quot;c&quot;,&quot;d&quot;])[&quot;a&quot;]</code></pre><h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h3><pre><code class="python">import pandas as pd#pd.date_range(start=None,end=None,periods=None,freq=&quot;D&quot;) D天 M月最后一天 H小时 MS每月第一题#start和end决定范围 freq决定频率 periods决定个数pd.date_range(start=&quot;20101010&quot;,end=&quot;20101030&quot;,freq=&quot;D&quot;)pd.date_range(start=&quot;20101010&quot;,periods = 10,freq=&quot;D&quot;)</code></pre><pre><code>DatetimeIndex([&#39;2010-10-10&#39;, &#39;2010-10-11&#39;, &#39;2010-10-12&#39;, &#39;2010-10-13&#39;,               &#39;2010-10-14&#39;, &#39;2010-10-15&#39;, &#39;2010-10-16&#39;, &#39;2010-10-17&#39;,               &#39;2010-10-18&#39;, &#39;2010-10-19&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><pre><code class="python">#时间字符串转化成Pandas的时间类型df[&quot;timeStamp&quot;] = pd.to_datetime(df[&quot;timeStamp&quot;],format=&quot;&quot;)</code></pre><pre><code class="python">#pandas重采样 从一个频率转化到另外一个频率 resampleimport pandas as pdimport numpy as npt = pd.DataFrame(np.random.uniform(10,50,(100,1)),index = pd.date_range(&quot;20170101&quot;,periods=100))print(t)</code></pre><pre><code>                    02017-01-01  29.9974172017-01-02  33.5089452017-01-03  41.1178392017-01-04  49.0781542017-01-05  11.675032...               ...2017-04-06  24.2460472017-04-07  41.7843472017-04-08  18.0150552017-04-09  18.9418282017-04-10  18.160647[100 rows x 1 columns]</code></pre><pre><code class="python">t.resample(&quot;M&quot;).mean() #按月求平均值</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>    </tr>  </thead>  <tbody>    <tr>      <th>2017-01-31</th>      <td>31.378624</td>    </tr>    <tr>      <th>2017-02-28</th>      <td>31.638050</td>    </tr>    <tr>      <th>2017-03-31</th>      <td>27.265000</td>    </tr>    <tr>      <th>2017-04-30</th>      <td>26.354586</td>    </tr>  </tbody></table></div><pre><code class="python">t.resample(&quot;10D&quot;).count()#按10天计数</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>    </tr>  </thead>  <tbody>    <tr>      <th>2017-01-01</th>      <td>10</td>    </tr>    <tr>      <th>2017-01-11</th>      <td>10</td>    </tr>    <tr>      <th>2017-01-21</th>      <td>10</td>    </tr>    <tr>      <th>2017-01-31</th>      <td>10</td>    </tr>    <tr>      <th>2017-02-10</th>      <td>10</td>    </tr>    <tr>      <th>2017-02-20</th>      <td>10</td>    </tr>    <tr>      <th>2017-03-02</th>      <td>10</td>    </tr>    <tr>      <th>2017-03-12</th>      <td>10</td>    </tr>    <tr>      <th>2017-03-22</th>      <td>10</td>    </tr>    <tr>      <th>2017-04-01</th>      <td>10</td>    </tr>  </tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
            <tag> Numpy </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Django</title>
      <link href="/2021/08/21/Python-Django/"/>
      <url>/2021/08/21/Python-Django/</url>
      
        <content type="html"><![CDATA[<h1 id="Django框架的MVC流程"><a href="#Django框架的MVC流程" class="headerlink" title="Django框架的MVC流程"></a>Django框架的MVC流程</h1><img src="/2021/08/21/Python-Django/image-20210821112056057.png" class title="image-20210821112056057"><h1 id="Django框架目录介绍"><a href="#Django框架目录介绍" class="headerlink" title="Django框架目录介绍"></a>Django框架目录介绍</h1><img src="/2021/08/21/Python-Django/image-20210821112901395.png" class title="image-20210821112901395"><h1 id="入门比较重要的命令"><a href="#入门比较重要的命令" class="headerlink" title="入门比较重要的命令"></a>入门比较重要的命令</h1><pre><code class="python">django-admin startproject mainproject # 创建项目python manage.py firstWEB #创建APP（进入工程目录）python manage.py makemigrations #创建库表（进入工程目录）python manage.py migrate  #执行库表建立（进入工程目录）#模板渲染嵌入语法：在html可以嵌入后台语言 区分符号-》&gt;   &#123;%命令%&#125; &#123;&#123;变量&#125;&#125;</code></pre><p>入门的几个设置</p><ul><li>Django框架时间设置</li><li>Django APP添加</li><li>Templates目录设置（在APP目录下，需要独立创建）</li></ul><p>安装Django</p><pre><code class="shell">pip install django</code></pre><pre><code>django-admin startproject mainproject # 创建项目python manage.py startapp firstWEB </code></pre><pre><code class="python">#--setting.py#允许什么地址访问你 如果主要内网访问 就加上“*,”ALLOWED_HOSTS = []# Application definitionINSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;firstWEB&#39;, #添加firstWEB]LANGUAGE_CODE = &#39;zh-Hans&#39; #语言TIME_ZONE = &#39;Asia/Beijing&#39; #时间STATIC_URL = &#39;/static/&#39; #静态文件目录</code></pre><p>点击运行，访问<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a></p><img src="/2021/08/21/Python-Django/image-20210821151001681.png" class title="image-20210821151001681"><pre><code class="python">#--urls.pyurlpatterns = [    path(&#39;admin/&#39;, admin.site.urls),   #path(&#39;打开的地址&#39;, 要调用映射的views中的文件)]</code></pre><pre><code class="python">#--views.pydef index(request): #request 请求    return render(request,&#39;index.html&#39;) #render渲染 #--urls.pyfrom firstWEB import viewsurlpatterns = [    path(&#39;admin/&#39;, admin.site.urls),    path(&#39;index/&#39;, views.index)]#在templates文件夹添加一个index.html文件，写上自己的网址即可，然后运行</code></pre><h1 id="创建一个加法页面"><a href="#创建一个加法页面" class="headerlink" title="创建一个加法页面"></a>创建一个加法页面</h1><pre><code class="python">#-- views.pydef CalPage(request):    return render(request,&#39;cal.html&#39;)#在templates文件夹下创建一个cal.html文件#--urls.pypath(&#39;calpage/&#39;,views.CalPage)path(&#39;cal&#39;,views.Cal) #调用加法函数</code></pre><pre><code class="python">#--views.pydef Cal(request):    value_a = request.POST[&#39;valueA&#39;]    value_b = request.POST[&#39;valueB&#39;]    result = int(value_b) + int(value_a)    return render(request,&quot;result.html&quot;,context=&#123;&#39;data&#39;:result&#125;)</code></pre><p>cal.html</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;计算页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;POST&quot; action=&quot;/cal&quot;&gt;    &#123;% csrf_token %&#125;    &lt;input type=&quot;number&quot; name=&quot;valueA&quot;&gt;    &lt;input type=&quot;number&quot; name=&quot;valueB&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交计算&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>result.html</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;结果页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;计算结果是:&lt;/h1&gt;&lt;h2&gt;&#123;&#123; data &#125;&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="保存数据到数据库"><a href="#保存数据到数据库" class="headerlink" title="保存数据到数据库"></a>保存数据到数据库</h2><p>models.py用来创建数据库</p><pre><code class="python">#--models.pyclass cal(models.Model): #表的描述    value_a = models.CharField(max_length=10)#定义字段类型    value_b = models.FloatField(max_length=10)    result = models.CharField(max_length=10)</code></pre><p>​</p><p>pycharm链接数据库</p><img src="/2021/08/21/Python-Django/image-20210822150531120.png" class title="image-20210822150531120"><img src="/2021/08/21/Python-Django/image-20210822150603585.png" class title="image-20210822150603585"><p>创建了表的描述并不是创建了表</p><p>所以还需要创建表</p><img src="/2021/08/21/Python-Django/image-20210822150851925.png" class title="image-20210822150851925"><img src="/2021/08/21/Python-Django/image-20210822151229961.png" class title="image-20210822151229961"><pre><code class="shell">python manage.py makemigrationspython manage.py migrate</code></pre><img src="/2021/08/21/Python-Django/image-20210822151337682.png" class title="image-20210822151337682"><h3 id="保存数据库"><a href="#保存数据库" class="headerlink" title="保存数据库"></a>保存数据库</h3><pre><code class="python">#--views.pyfrom .models import caldef Cal(request):    value_a = request.POST[&#39;valueA&#39;]    value_b = request.POST[&#39;valueB&#39;]    result = int(value_b) + int(value_a)    cal.objects.create(value_a = value_a,value_b = value_b,result = result)    return render(request,&quot;result.html&quot;,context=&#123;&#39;data&#39;:result&#125;) </code></pre><h3 id="把页面打印出来"><a href="#把页面打印出来" class="headerlink" title="把页面打印出来"></a>把页面打印出来</h3><p>在templates中创建一个list.html的文件</p><pre><code class="python">#--views.pydef CalList(request):    data = cal.objects.all()    retuen render(request,&#39;list.html&#39;,context=&#123;&#39;data&#39;:data&#125;)</code></pre><pre><code class="python">#--urls.pypath(&#39;list&#39;,views.CalList)</code></pre><p>list.html</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Cal list&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;valueA&lt;/th&gt;        &lt;th&gt;valueB&lt;/th&gt;        &lt;th&gt;result&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &#123;% for data1 in data %&#125;    <tr>        <td>&#123;&#123; data.value_a &#125;&#125;</td>        <td>&#123;&#123; data.value_b &#125;&#125;</td>        <td>&#123;&#123; data.result &#125;&#125;</td>    </tr>    &#123;% endfor %&#125;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><img src="/2021/08/21/Python-Django/image-20210823154237357.png" class title="image-20210823154237357"><h3 id="清库功能"><a href="#清库功能" class="headerlink" title="清库功能"></a>清库功能</h3><p>list.html</p><pre><code class="html">&lt;form method=&quot;POST&quot; action=&quot;/del&quot;&gt;    &#123;% csrf_token %&#125;    &lt;input type=&quot;submit&quot; value=&quot;清库&quot;&gt;&lt;/form&gt;</code></pre><pre><code class="python">#--urls.pypath(&#39;del&#39;,views.deldata)</code></pre><pre><code class="python">#--views.pyfrom django.http import HttpResponsedef deldata(request):    cal.objects.all().delete()    return HttpResponse(&#39;Data Deleted&#39;)</code></pre><h2 id="加法页面总结"><a href="#加法页面总结" class="headerlink" title="加法页面总结"></a>加法页面总结</h2><pre><code class="python">#--models.pyfrom django.db import models# Create your models here.class cal(models.Model): #表的描述    value_a = models.CharField(max_length=10)#定义字段类型    value_b = models.FloatField(max_length=10)    result = models.CharField(max_length=10)</code></pre><pre><code class="python">#--views.pyfrom django.shortcuts import renderfrom firstWEB import modelsfrom .models import calfrom django.http import HttpResponse# Create your views here.#渲染页面返回到前端def index(request): #request 请求    return render(request,&#39;index.html&#39;) #render渲染def CalPage(request):    return render(request,&#39;cal.html&#39;)def Cal(request):    value_a = request.POST[&#39;valueA&#39;]    value_b = request.POST[&#39;valueB&#39;]    result = int(value_b) + int(value_a)    cal.objects.create(value_a = value_a,value_b = value_b,result = result)    return render(request,&quot;result.html&quot;,context=&#123;&#39;data&#39;:result&#125;)def CalList(request):    data = cal.objects.all()    return render(request,&#39;list.html&#39;,context=&#123;&#39;data&#39;:data&#125;)def deldata(request):    cal.objects.all().delete()    return HttpResponse(&#39;Data Deleted&#39;)</code></pre><pre><code class="python">#--urls.py&quot;&quot;&quot;mainproject URL ConfigurationThe `urlpatterns` list routes URLs to views. For more information please see:    https://docs.djangoproject.com/en/3.2/topics/http/urls/Examples:Function views    1. Add an import:  from my_app import views    2. Add a URL to urlpatterns:  path(&#39;&#39;, views.home, name=&#39;home&#39;)Class-based views    1. Add an import:  from other_app.views import Home    2. Add a URL to urlpatterns:  path(&#39;&#39;, Home.as_view(), name=&#39;home&#39;)Including another URLconf    1. Import the include() function: from django.urls import include, path    2. Add a URL to urlpatterns:  path(&#39;blog/&#39;, include(&#39;blog.urls&#39;))&quot;&quot;&quot;from django.contrib import adminfrom django.urls import pathfrom firstWEB import viewsurlpatterns = [    path(&#39;admin/&#39;, admin.site.urls),    path(&#39;index/&#39;, views.index),    path(&#39;calpage/&#39;,views.CalPage),    path(&#39;cal&#39;,views.Cal),    path(&#39;list&#39;,views.CalList),    path(&#39;del&#39;,views.deldata)]</code></pre><pre><code class="html">&lt;!--cal.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;计算页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;POST&quot; action=&quot;/cal&quot;&gt;    &#123;% csrf_token %&#125;    &lt;input type=&quot;number&quot; name=&quot;valueA&quot;&gt;    &lt;input type=&quot;number&quot; name=&quot;valueB&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交计算&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="html">&lt;!--list.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Cal list&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;valueA&lt;/th&gt;        &lt;th&gt;valueB&lt;/th&gt;        &lt;th&gt;result&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &#123;% for data1 in data %&#125;    <tr>        <td>&#123;&#123; data1.value_a &#125;&#125;</td>        <td>&#123;&#123; data1.value_b &#125;&#125;</td>        <td>&#123;&#123; data1.result &#125;&#125;</td>    </tr>    &#123;% endfor %&#125;&lt;/table&gt;&lt;form method=&quot;POST&quot; action=&quot;/del&quot;&gt;    &#123;% csrf_token %&#125;    &lt;input type=&quot;submit&quot; value=&quot;清库&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="html">&lt;!--result.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;结果页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;计算结果是:&lt;/h1&gt;&lt;h2&gt;&#123;&#123; data &#125;&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器视觉-笔记</title>
      <link href="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h1><h2 id="难在哪？"><a href="#难在哪？" class="headerlink" title="难在哪？"></a>难在哪？</h2><ol><li>视角</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820110246190.png" class title="image-20210820110246190"><ol start="2"><li>光照</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820110302276.png" class title="image-20210820110302276"><ol start="3"><li>尺度</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820110320313.png" class title="image-20210820110320313"><ol start="4"><li>遮挡</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820110610387.png" class title="image-20210820110610387"><ol start="5"><li>形变</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820110959388.png" class title="image-20210820110959388"><ol start="6"><li>背景杂波</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820111140862.png" class title="image-20210820111140862"><ol start="7"><li>类内形变</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820111226176.png" class title="image-20210820111226176"><ol start="8"><li>运动模糊</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820111324680.png" class title="image-20210820111324680"><ol start="9"><li>类别繁多</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820111546677.png" class title="image-20210820111546677"><h2 id="数据驱动的图像分类"><a href="#数据驱动的图像分类" class="headerlink" title="数据驱动的图像分类"></a>数据驱动的图像分类</h2><ol><li>数据集构建</li><li>分类器设计与学习</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820143045672.png" class title="image-20210820143045672"><ol start="3"><li>分类器决策</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820143256582.png" class title="image-20210820143256582"><h2 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h2><h3 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1.数据集"></a>1.数据集</h3><p>CIFAR10数据集</p><h3 id="2-分类器设计"><a href="#2-分类器设计" class="headerlink" title="2.分类器设计"></a>2.分类器设计</h3><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820145631178.png" class title="image-20210820145631178"><h4 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h4><p>图像类型：</p><p>二进制图像：只有黑和白</p><p>灰度图像：每个点一个值（0~255）</p><p>彩色图像：每个点3个值（RGB）</p><p>大多数分类算法都要求<strong>输入向量</strong></p><p>最简单的直接将图像矩阵转化为向量</p><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820150204504.png" class title="image-20210820150204504"><h3 id="3-线性分类器的定义"><a href="#3-线性分类器的定义" class="headerlink" title="3.线性分类器的定义"></a>3.线性分类器的定义</h3><p>线性分类器是一种线性映射，将输入的图像特征映射为类别分数。</p><ol><li>形式简单、易于理解</li><li>通过层级结构（神经网络）或高维映射（支持向量机）可以形成功能强大的非线性模型</li></ol><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820150757884.png" class title="image-20210820150757884"><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820150840316.png" class title="image-20210820150840316"> <img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820151355997.png" class title="image-20210820151355997"><img src="/2021/08/20/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E7%AC%94%E8%AE%B0/image-20210820151637585.png" class title="image-20210820151637585"><h3 id="4-线性分类器的权值"><a href="#4-线性分类器的权值" class="headerlink" title="4.线性分类器的权值"></a>4.线性分类器的权值</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-排序</title>
      <link href="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层<a href="https://www.zhihu.com/search?q=%E5%88%86%E6%B2%BB%E9%80%92%E5%BD%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:124356219%7D">分治递归</a>可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><h2 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h2><p>归并排序是用分治思想，分治模式在每一层递归上有三个步骤：</p><ul><li><strong>分解（Divide）</strong>：将n个元素分成个含n&#x2F;2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ul><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" class title="img"><h2 id="2-图解"><a href="#2-图解" class="headerlink" title="2.图解"></a>2.图解</h2><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_1440w.jpg" class title="img">3.复杂度分析</h2><blockquote><p>平均时间复杂度：O(nlogn)<br>最佳时间复杂度：O(n)<br>最差时间复杂度：O(nlogn)<br><a href="https://www.zhihu.com/search?q=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:124356219%7D">空间复杂度</a>：O(n)<br>排序方式：In-place<br>稳定性：稳定</p></blockquote><p>归并排序算法中，归并最后到底都是相邻元素之间的比较交换，并不会发生相同元素的相对位置发生变化，故是稳定性算法。</p><h1 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h1><h2 id="一、堆的相关概念"><a href="#一、堆的相关概念" class="headerlink" title="一、堆的相关概念"></a>一、堆的相关概念</h2><p>堆一般指的是二叉堆，顾名思义，<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E5%8F%89&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:124885051%7D">二叉</a>堆是完全二叉树或者近似完全二叉树</p><ol><li><p>堆的性质</p><blockquote><p>① 是一棵<a href="https://www.zhihu.com/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:124885051%7D">完全二叉树</a></p><p>② 每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</p></blockquote><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-a78e7c4a1cc919a322adc87b33006dab_1440w-16384278060616.jpg" class title="img"></li><li><p>堆的存储</p></li></ol><p>一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)&#x2F;2；其左右子结点分别为 (2i + 1)、(2i + 2)</p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-54a318a1acd0cccb8ac0018ccf58815f_1440w.jpg" class title="img"><ol start="3"><li>堆的操作</li></ol><p>在堆的数据结构中，堆中的最大值总是位于根节点(在<a href="https://www.zhihu.com/search?q=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:124885051%7D">优先队列</a></p><p>中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p><blockquote><p>① <strong>最大堆调整（Max_Heapify）</strong>：将堆的末端子节点作调整，使得子节点永远小于父节点<br>② <strong>创建最大堆（Build_Max_Heap）</strong>：将堆所有数据重新排序<br>③ <strong>堆排序（HeapSort）</strong>：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p></blockquote><h2 id="二、堆排序（Heap-Sort）"><a href="#二、堆排序（Heap-Sort）" class="headerlink" title="二、堆排序（Heap Sort）"></a>二、堆排序（Heap Sort）</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="1-基本思想-1"><a href="#1-基本思想-1" class="headerlink" title="1. 基本思想"></a>1. 基本思想</h3><p>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。</p><blockquote><p>① 将待排序的序列构造成一个最大堆，此时序列的最大值为根节点<br>② 依次将根节点与待排序序列的最后一个元素交换<br>③ 再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列</p></blockquote><h3 id="2-实现逻辑"><a href="#2-实现逻辑" class="headerlink" title="2. 实现逻辑"></a>2. 实现逻辑</h3><blockquote><p>① 先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素。<br>② 再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key<br>③  由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。<br>④ 直到无序区只有一个元素为止。</p></blockquote><h3 id="3-动图演示"><a href="#3-动图演示" class="headerlink" title="3. 动图演示"></a>3. 动图演示</h3><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-b7907d351809293c60658b0b87053c66_b.webp" class title="img"><p>堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。</p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-7073c729230e1a2c3c3c9207b25f6b43_b.jpg" class title="img"><p><video class="ztext-gif GifPlayer-gif2mp4" src="https://vdn1.vzuu.com/SD/3bb38dfe-236a-11eb-8039-a6caf32b14c9.mp4?disable_local_cache=1&amp;auth_key=1638431242-0-0-af79a774fa36e1f7244aeb20ff0fbcd8&amp;f=mp4&amp;bu=pico&amp;expiration=1638431242&amp;v=hw" data-thumbnail="https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_b.jpg" poster="https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_b.jpg" data-size="normal" preload="metadata" loop playsinline __idm_id__="333708289"></video></p><p><strong>分步解析说明</strong>： </p><p>实现堆排序需要解决两个问题：</p><blockquote><p>1、如何由一个无序序列建成一个堆？<br>2、如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p></blockquote><p> 假设给定一个组无序数列{100,5,3,11,6,8,7}，带着问题，我们对其进行堆排序操作进行分步操作说明。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-acbdde7cf6f0426e693187c4899716e7_1440w.png" class title="img"><h3 id="3-1-创建最大堆"><a href="#3-1-创建最大堆" class="headerlink" title="3.1 创建最大堆"></a>3.1 创建最大堆</h3><p>①首先我们将数组我们将数组从上至下按顺序排列，转换成<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E5%8F%89%E6%A0%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:124885051%7D">二叉树</a></p><p>：一个无序堆。每一个<a href="https://www.zhihu.com/search?q=%E4%B8%89%E8%A7%92%E5%85%B3%E7%B3%BB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:124885051%7D">三角关系</a></p><p>都是一个堆，上面是父节点，下面两个分叉是子节点，两个子节点俗称左孩子、右孩子； </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-6db33bd4ddb7937ca5946283ef2acc5d_1440w.jpg" class title="img"><p>②转换成无序堆之后，我们要努力让这个无序堆变成最大堆(或是最小堆)，即每个堆里都实现父节点的值都大于任何一个子节点的值。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-6db33bd4ddb7937ca5946283ef2acc5d_1440w.jpg" class title="img"><p>③从最后一个堆开始，即左下角那个没有右孩子的那个堆开始；首先对比左右孩子，由于这个堆没有右孩子，所以只能用左孩子，左孩子的值比父节点的值小所以不需要交换。如果发生交换，要检测子节点是否为其他堆的父节点，如果是，递归进行同样的操作。</p><p>④第二次对比红色三角形内的堆，取较大的子节点，右孩子8胜出，和父节点比较，右孩子8大于父节点3，升级做父节点，与3交换位置，3的位置没有子节点，这个堆建成最大堆。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-29c3af6ba60e66f1d328c164d09b4adc_1440w.jpg" class title="img"><p>⑤对黄色三角形内堆进行排序，过程和上面一样，最终是右孩子33升为父节点，被交换的右孩子下面也没有子节点，所以直接结束对比。</p><p>⑥最顶部绿色的堆，堆顶100比左右孩子都大，所以不用交换，至此最大堆创建完成。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-cf88501a8092e7b0c4712aa81a875f03_1440w.jpg" class title="img"><h3 id="3-2-堆排序（最大堆调整）"><a href="#3-2-堆排序（最大堆调整）" class="headerlink" title="3.2 堆排序（最大堆调整）"></a>3.2 堆排序（最大堆调整）</h3><p>①首先将堆顶元素100交换至最底部7的位置，7升至堆顶，100所在的底部位置即为有序区，有序区不参与之后的任何对比。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-e96b570c470785e19936abceee95c8ca_1440w.jpg" class title="img"><p>②在7升至顶部之后，对顶部重新做最大堆调整，左孩子33代替7的位置。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-5bbfec3cb200b9fa7efcf29fe71fc7dd_1440w.jpg" class title="img"><p>③在7被交换下来后，下面还有子节点，所以需要继续与子节点对比，左孩子11比7大，所以11与7交换位置，交换位置后7下面为有序区，不参与对比，所以本轮结束，无序区再次形成一个最大堆。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-1f490e927a5d7d5e97e9609f7e99b6e5_1440w.jpg" class title="img"><p>④将最大堆堆顶33交换至堆末尾，扩大有序区； </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-d77c2cf77a7b81041fba5871979f3910_1440w.jpg" class title="img"><p>⑤不断建立最大堆，并且扩大有序区，最终全部有序。 </p><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-724e54aaff73bd4c0bf5e5352fc673ce_1440w.jpg" class title="img"><h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><ul><li>平均时间复杂度：O(nlogn)</li><li>最佳时间复杂度：O(nlogn)</li><li>最差时间复杂度：O(nlogn)</li><li>稳定性：不稳定</li></ul><p>堆排序其实也是一种选择排序，是一种树形选择排序。只不过直接选择排序中，为了从R[1…n]中选择最大记录，需比较n-1次，然后从R[1…n-2]中选择最大记录需比较n-2次。事实上这n-2次比较中有很多已经在前面的n-1次比较中已经做过，而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。对于n个关键字序列，最坏情况下每个节点需比较log2(n)次，因此其最坏情况下时间复杂度为nlogn。堆排序为不稳定排序，不适合记录较少的排序。</p><h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p>快速排序，又称<a href="https://www.zhihu.com/search?q=%E5%88%92%E5%88%86%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:123416868%7D">划分交换排序</a></p><p>（partition-exchange sort）</p><h2 id="1-基本思想-2"><a href="#1-基本思想-2" class="headerlink" title="1.基本思想"></a>1.基本思想</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h2 id="2-实现逻辑-1"><a href="#2-实现逻辑-1" class="headerlink" title="2. 实现逻辑"></a>2. 实现逻辑</h2><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><blockquote><p>① 从数列中挑出一个元素，称为 “基准”（pivot），<br>② 重新排序数列，所有元素比<a href="https://www.zhihu.com/search?q=%E5%9F%BA%E5%87%86%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:123416868%7D">基准值</a></p></blockquote><blockquote><p>小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></blockquote><p> 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h2 id="3-动图演示-1"><a href="#3-动图演示-1" class="headerlink" title="3. 动图演示"></a>3. 动图演示</h2><img src="/2021/08/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/v2-d4e5d0a778dba725091d8317e6bac939_b.webp" class title="img"><p>快速排序</p><h2 id="4-复杂度"><a href="#4-复杂度" class="headerlink" title="4. 复杂度"></a>4. <a href="https://www.zhihu.com/search?q=%E5%A4%8D%E6%9D%82%E5%BA%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:123416868%7D">复杂度</a></h2><p>平均时间复杂度：O(NlogN)<br>最佳时间复杂度：O(NlogN)<br>最差<a href="https://www.zhihu.com/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:123416868%7D">时间复杂度</a>：O(N^2)<br>空间复杂度：根据实现方式的不同而不同</p><p><strong>参考资料：</strong></p><ol><li><p><a href="https://zhuanlan.zhihu.com/p/124356219">【算法】排序算法之归并排序 </a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/124885051">【算法】排序算法之堆排序</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/123416868">【算法】排序算法之快速排序</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-递归</title>
      <link href="/2021/08/16/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
      <url>/2021/08/16/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>假设你在祖母的阁楼中翻箱倒柜，发现了一个上锁的神秘手提箱。</p><p>祖母告诉你，钥匙很可能在下面这个盒子里。</p><img src="/2021/08/16/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/image-20210816113953962.png" class title="image-20210816113953962"><p>这个盒子里有盒子，而盒子里的盒子又有盒子。钥匙就在某个盒子中。</p><p>方法1：</p><p>(1) 创建一个要查找的盒子堆。</p><p>(2) 从盒子堆取出一个盒子，在里面找。</p><p>(3) 如果找到的是盒子，就将其加入盒子堆中，以便以后再查找。</p><p>(4) 如果找到钥匙，则大功告成！</p><p>(5) 回到第二步。</p><img src="/2021/08/16/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/image-20210816114206662.png" class title="image-20210816114206662"><p>方法2：</p><p>(1) 检查盒子中的每样东西。</p><p>(2) 如果是盒子，就回到第一步。</p><p>(3) 如果是钥匙，就大功告成！</p><img src="/2021/08/16/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/image-20210816114233571.png" class title="image-20210816114233571"><p>第一种方法使用的是while循环：只要盒子堆不空，就从中</p><p>取一个盒子，并在其中仔细查找。</p><pre><code class="python">def look_for_key(main_box):     pile = main_box.make_a_pile_to_look_through()     while pile is not empty:         box = pile.grab_a_box()         for item in box:             if item.is_a_box():                 pile.append(item)             elif item.is_a_key():                 print &quot;found the key!&quot; </code></pre><p>第二种方法使用递归——函数调用自己，这种方法的伪代码如下。</p><pre><code class="python">def look_for_key(box):     for item in box:         if item.is_a_box():             look_for_key(item)        elif item.is_a_key():             print &quot;found the key!&quot; </code></pre><p>递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。</p><p>Leigh Caldwell在Stack Overflow上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”</p><h1 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h1><p>递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。</p><p>每个递归函数都有两部分：基线</p><p>条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。</p><p>例如</p><pre><code class="python">def countdown(i):    print(i)    if i&lt;=0:    &lt;---基线条件        retuen    else:      &lt;--- 递归条件        countdown(i-1)</code></pre><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>先进的后出</p><p>只有两种操作：压入（插入）和弹出（删除并读取）。</p><h2 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h2><p>例如</p><pre><code class="python">def fact(x):    if x==1:        return 1    else:        return x*fact(x-1)</code></pre><p>下面来详细分析调用fact(3)时调用栈是如何变化的。别忘了，栈顶的方框指出了当前执行到了什么地方。</p><img src="/2021/08/16/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/image-20210817144014326.png" class title="image-20210817144014326"><img src="/2021/08/16/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/image-20210817144115692.png" class title="image-20210817144115692"><p>使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。</p><ul><li><p>重新编写代码，转而使用循环。</p></li><li><p>使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言都支持尾递归。</p></li></ul><p>小结</p><ol><li><p>递归指的是调用自己的函数。</p></li><li><p>每个递归函数都有两个条件：基线条件和递归条件。</p></li><li><p>栈有两种操作：压入和弹出。</p></li><li><p>所有函数调用都进入调用栈。</p></li><li><p>调用栈可能很长，这将占用大量的内存。</p></li></ol><p><strong>参考：</strong></p><p>1.算法图解</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维前缀和</title>
      <link href="/2021/08/14/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2021/08/14/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h1><p>一维前缀和就是一维的前缀和，前缀和就是到目前为止全部的和是多少。</p><p><strong>【举例】</strong></p><p>1 2 3 4 5 6<br> 他的前缀和依次就是 1 3 6 10 15 21<br>i位置上的前缀和就是从第一个数到第i个数全部数的和</p><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>二维前缀和就是二维的前缀和</p><p>二维有x轴和y轴也就是一个面</p><p>二维前缀和中一个f[i][j]表示的意思就是<br> 以（1,1）为左上角以（i,j）为右下角这个矩阵里面数的和<br> 如图<br> <img src="undefined2021/08/14/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/0dwklyet.png" alt="img"><br> f[i][j]表示的就是图中红色的部分</p><h2 id="如何求二维前缀和"><a href="#如何求二维前缀和" class="headerlink" title="如何求二维前缀和"></a>如何求二维前缀和</h2><pre><code>D点表示的二维前缀和值是红色部分+两个黄色部分+黑色部分A点表示的是红色部分B点表示的是上面的黄色部分+红色部分C点表示的是下面的黄色部分+红色部分</code></pre><img src="/2021/08/14/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/image-20210815153224497.png" class title="image-20210815153224497"><p>D &#x3D; C + B - A + 黑色部分</p><p><em>f</em>[<em>i</em>][<em>j</em>] &#x3D; <em>f</em>[<em>i</em>−1][<em>j</em>] + <em>f</em>[<em>i</em>][<em>j</em>−1] − <em>f</em>[<em>i</em>−1][<em>j</em>−1] + <em>a</em>[<em>i</em>][<em>j</em>]</p><h2 id="二维前缀和求矩阵元素和"><a href="#二维前缀和求矩阵元素和" class="headerlink" title="二维前缀和求矩阵元素和"></a>二维前缀和求矩阵元素和</h2><p>二维前缀和作用：</p><p>一维前缀和你可以用来O(1)求某个点的值，二维前缀和也是可以用来求某个矩阵的值的。</p><img src="undefined2021/08/14/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/bf61v64j.png" alt="img" style="zoom:130%;"><p>知道了两个点的位置和他们的二维前缀和</p><p>图中红色是左上角的那个点的二维前缀和<br>红色+黄色部分是右下角的那个点的二维前缀和</p><p>是不是可以用这个来求出他们之间的矩阵的和呢？<br> 也就是这一部分： </p><p>​                                            <img src="undefined2021/08/14/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/cjmiifza.png" alt="img" style="zoom:130%;"> </p><p>图中黑色的部分就是我们要求的那个矩阵和</p><img src="/2021/08/14/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/image-20210815153230012.png" class title="image-20210815153230012"><pre><code>D点表示的二维前缀和值是红色部分+两个黄色部分+黑色部分A点表示的是红色部分B点表示的是上面的黄色部分+红色部分C点表示的是下面的黄色部分+红色部分</code></pre><p>黑色部分为1*1</p><p>黑色部分 &#x3D; D - B - C + A</p><p>黑色部分 &#x3D; <em>f</em>[<em>i</em>][<em>j</em>] − <em>f</em>[<em>i</em>−1][<em>j</em>] − <em>f</em>[<em>i</em>][<em>j</em>−1] + <em>f</em>[<em>i</em>−1][<em>j</em>−1]</p><p>参考：</p><ol><li><a href="https://www.cnblogs.com/acioi/p/11705205.html#%E3%80%90%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%91">https://www.cnblogs.com/acioi/p/11705205.html#%E3%80%90%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%91</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-笔记</title>
      <link href="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NumPy函数库"><a href="#NumPy函数库" class="headerlink" title="NumPy函数库"></a>NumPy函数库</h1><pre><code class="python">from numpy import *</code></pre><p>生成一个4*4的数组</p><pre><code class="python">&gt;&gt;&gt; numpy.random.rand(4,4)array([[0.80163081, 0.23008351, 0.44863583, 0.92603239],       [0.63965392, 0.54158411, 0.14149293, 0.96833658],       [0.65969625, 0.27623482, 0.04088929, 0.33459342],       [0.86289853, 0.25951974, 0.74760047, 0.34809279]])</code></pre><p>numpy中存在两种不同的数据类型（矩阵matrix和数组array），都可以用于处理行列表示的数字元素，虽然看起来相似但在处理相同的数学运算可得到不同的结果。</p><pre><code class="python">mat(numpy.random.rand(4,4)) #可将数组转化为矩阵</code></pre><pre><code class="python">&gt;&gt;&gt; randMat = numpy.mat(numpy.random.rand(4,4))&gt;&gt;&gt; print(randMat)[[0.71706946 0.1258772  0.55510408 0.12352685] [0.11085632 0.4458693  0.02158896 0.67959614] [0.23393777 0.9965666  0.1254053  0.92926846] [0.02608629 0.5341115  0.57497612 0.97052454]]</code></pre><p>.I操作符实现了矩阵求逆的运算</p><pre><code class="python">&gt;&gt;&gt;randMat.Imatrix([[ 1.26256632e+00,  2.11443878e+00, -4.63873260e-01,         -1.19714901e+00],        [-3.29391380e-01, -3.30669883e+00,  2.59029623e+00,         -1.22791482e-01],        [ 2.44676089e-01, -2.73432913e+00,  3.75829650e-01,          1.52367998e+00],        [ 2.38340118e-03,  3.38287376e+00, -1.63571275e+00,          2.27437740e-01]])</code></pre><p>eye(4)可生成一个4*4的单位阵</p><pre><code class="python">&gt;&gt;&gt; numpy.eye(4)array([[1., 0., 0., 0.],       [0., 1., 0., 0.],       [0., 0., 1., 0.],       [0., 0., 0., 1.]])</code></pre><pre><code class="python">dataSet.shape[0] #读取矩阵的长度,读取第一维度的长度</code></pre><p>tile函数</p><pre><code class="python">Examples    --------    &gt;&gt;&gt; a = np.array([0, 1, 2])    &gt;&gt;&gt; np.tile(a, 2)    array([0, 1, 2, 0, 1, 2]) #向一个维度扩展（横向）    &gt;&gt;&gt; np.tile(a, (2, 2))    array([[0, 1, 2, 0, 1, 2],           [0, 1, 2, 0, 1, 2]]) #向两个维度扩展【行方向（横向）与列方向（纵向）】    &gt;&gt;&gt; np.tile(a, (2, 1, 2))    array([[[0, 1, 2, 0, 1, 2]],           [[0, 1, 2, 0, 1, 2]]])#向3个维度扩展，与二维的不同在于reps的第一个参数代表扩展几块，这里是2块，第二和第三个参数才代表扩展后的维度（有几行，有几列）</code></pre><p>​    </p><pre><code class="python">&gt;&gt;&gt; b = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; np.tile(b, 2) #b是一个整体元素，这里在一维上进行扩展，也就是横向复制array([[1, 2, 1, 2],       [3, 4, 3, 4]]) &gt;&gt;&gt; np.tile(b, (2, 1))#b是一个整体元素，在行方向上由1个复制为2个，列方向为1，所以不复制array([[1, 2],       [3, 4],       [1, 2],       [3, 4]])&gt;&gt;&gt; c = np.array([1,2,3,4])&gt;&gt;&gt; np.tile(c,(4,1))array([[1, 2, 3, 4],       [1, 2, 3, 4],       [1, 2, 3, 4],       [1, 2, 3, 4]])</code></pre><p>numpy.sum中axis属性</p><p>现在对于数据的处理更多的还是numpy。没有axis参数表示全部相加，axis＝0表示按列相加，axis＝1表示按照行的方向相加</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]])&gt;&gt;&gt; a9&gt;&gt;&gt; a.shape()&gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]],axis=0)&gt;&gt;&gt; aarray([2, 2, 5])&gt;&gt;&gt; a.shape(3,)&gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]],axis=1)&gt;&gt;&gt; aarray([3, 6])&gt;&gt;&gt; a.shape(2,)</code></pre><p>argsort()函数是将x中的元素从小到大排列，提取其对应的index(索引号)</p><pre><code class="python">&gt;&gt;&gt; x = np.array([3, 1, 2])&gt;&gt;&gt; np.argsort(x) #按升序排列array([1, 2, 0])&gt;&gt;&gt; np.argsort(-x) #按降序排列array([0, 2, 1])One dimensional array:一维数组    &gt;&gt;&gt; x = np.array([3, 1, 2])    &gt;&gt;&gt; np.argsort(x)    array([1, 2, 0])    Two-dimensional array:二维数组    &gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])    &gt;&gt;&gt; x    array([[0, 3],           [2, 2]])    &gt;&gt;&gt; np.argsort(x, axis=0) #按列排序    array([[0, 1],           [1, 0]])    &gt;&gt;&gt; np.argsort(x, axis=1) #按行排序    array([[0, 1],           [0, 1]])</code></pre><h2 id="将文本记录到转换NumPy的解析程序"><a href="#将文本记录到转换NumPy的解析程序" class="headerlink" title="将文本记录到转换NumPy的解析程序"></a>将文本记录到转换NumPy的解析程序</h2><pre><code class="python">def file2matrix(filename):    love_dictionary = &#123;&#39;largeDoses&#39;:3, &#39;smallDoses&#39;:2, &#39;didntLike&#39;:1&#125;    fr = open(filename)    arrayOLines = fr.readlines()#readlines() 方法用于读取所有行(直到结束符 EOF)并返回列表。    numberOfLines = len(arrayOLines)#获取文件行数    returnMat = np.zeros((numberOfLines, 3))        ## 创建一个初始值为0，大小为 numberOfLines x 3 的数组    classLabelVector = []#用于保存每个数据的类别标签    index = 0    for line in arrayOLines:        line = line.strip()#截取掉所有的回车字符        listFromLine = line.split(&#39;\t&#39;) # 分割每行数据，保存到一个列表中        returnMat[index, :] = listFromLine[0:3]#将数据前三列提取出来，存放到returnMat的numpy矩阵中，也就是不含标签变量，只有特征变量。        if(listFromLine[-1].isdigit()):            # 直接赋值给classLabelVector            classLabelVector.append(int(listFromLine[-1]))# 保存分类标签        else:            # 如果listFromLine最后一个元素不是数字，而是字符串。根据字典love_dictionary转化为数字            # Python 字典(Dictionary) get() 函数返回指定键的值            classLabelVector.append(love_dictionary.get(listFromLine[-1]))        index += 1    return returnMat,classLabelVector</code></pre><h1 id="operator函数库"><a href="#operator函数库" class="headerlink" title="operator函数库"></a>operator函数库</h1><h2 id="itemgetter"><a href="#itemgetter" class="headerlink" title="itemgetter"></a>itemgetter</h2><p>operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号（即需要获取的数据在对象中的序号），下面看例子。</p><pre><code class="python">1 k = [3,6,8]2 b = operator.itemgetter(1)3 print(b(k))4 #输出61 k = [3,6,8]2 b = operator.itemgetter(2,0)3 print(b(k))4 #输出(8, 3)</code></pre><p>要注意，operator.itemgetter函数获取的不是值，而是定义了一个函数，通过该函数作用到对象上才能获取值。</p><pre><code class="python">1 students = [(&#39;john&#39;, &#39;C&#39;, 15), (&#39;jane&#39;, &#39;A&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]2 s = sorted(students,key = operator.itemgetter(1,2))3 print(s)4 #输出[(&#39;jane&#39;, &#39;A&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10), (&#39;john&#39;, &#39;C&#39;, 15)]</code></pre><h1 id="Matplotlib函数库"><a href="#Matplotlib函数库" class="headerlink" title="Matplotlib函数库"></a>Matplotlib函数库</h1><p><a href="https://www.runoob.com/numpy/numpy-matplotlib.html">https://www.runoob.com/numpy/numpy-matplotlib.html</a></p><p><a href="https://www.runoob.com/w3cnote/matplotlib-tutorial.html">https://www.runoob.com/w3cnote/matplotlib-tutorial.html</a></p><p>subplot() 函数允许你在同一图中绘制不同的东西。</p><pre><code class="python">from matplotlib import pyplot as pltplt.savefig(‘test’, dpi = 600) #将绘制的图画保存成png格式，命名为 testplt.ylabel(&#39;y坐标名称&#39;) # y轴的名称plt.xlabel(&#39;x坐标名称&#39;)plt.axis([-1, 10, 0, 6]) #x轴起始于-1，终止于10 ，y轴起始于0，终止于6plt.plot(x,y)#绘制plt.subplot(3,2,4) #分成3行2列，共6个绘图区域，在第4个区域绘图。排序为行优先。也可 plt.subplot(324)，将逗号省略。plt.show() #显示图形</code></pre><h2 id="plot函数"><a href="#plot函数" class="headerlink" title=".plot函数"></a>.plot函数</h2><pre><code>plt.plot(x, y, format_string, **kwargs): x为x轴数据，可为列表或数组；y同理；format_string 为控制曲线的格式字符串， **kwargs 第二组或更多的（x, y, format_string）format_string: 由 颜色字符、风格字符和标记字符组成。颜色字符：‘b’蓝色 ；‘#008000’RGB某颜色；‘0.8’灰度值字符串风格字符：‘-’实线；‘--’破折线； ‘-.’点划线； ‘：’虚线 ； ‘’‘’无线条标记字符：‘.’点标记 ‘o’ 实心圈 ‘v’倒三角 ‘^’上三角 eg： plt.plot(a, a*1.5, ‘go-’,  a, a*2, ‘*’)  第二条无曲线，只有点</code></pre><h2 id="plot-显示中文字符"><a href="#plot-显示中文字符" class="headerlink" title=".plot 显示中文字符"></a>.plot 显示中文字符</h2><pre><code>pyplot并不默认支持中文显示，需要rcParams修改字体来实现rcParams的属性：‘font.family’ 用于显示字体的名字‘font.style’ 字体风格，正常’normal’ 或斜体’italic’‘font.size’ 字体大小，整数字号或者’large’  ‘x-small’eg:import matplotlibmatplotlib.rcParams[‘font.family’] = ‘STSong’matplotlib.rcParams[‘font.size’] = 20设定绘制区域的全部字体变成 华文仿宋，字体大小为20中文显示2：只希望在某地方绘制中文字符，不改变别的地方的字体在有中文输出的地方，增加一个属性： fontpropertieseg:plt.xlabel(‘横轴：时间’, fontproperties = ‘simHei’, fontsize = 20)</code></pre><h2 id="pyplot文本显示函数："><a href="#pyplot文本显示函数：" class="headerlink" title="pyplot文本显示函数："></a>pyplot文本显示函数：</h2><pre><code class="python">plt.xlabel()#对x轴增加文本标签plt.ylabel()#同理plt.title()#对图形整体增加文本标签plt.text()#在任意位置增加文本plt. annotate(s, xy = arrow_crd, xytext = text_crd, arrowprops = dict)#在图形中增加带箭头的注解。s表示要注解的字符串是什么，xy对应箭头所在的位置，xytext对应文本所在位置，arrowprops定义显示的属性eg:plt.xlabel(‘横轴：时间’， fontproperties = ‘SimHei’, fontsize = 15, color = ‘green’)plt.ylabel(‘纵轴：振幅’, fontproperties = ‘SimHei’, fontsize = 15)plt.title(r’正弦波实例 $y=cons(2\pi x)$’ , fontproperties = ‘SimHei’, fontsize = 25)plt.annotate (r’%mu=100$, xy = (2, 1), xytext = (3, 1.5),arrowprops = dict(facecolor = ‘black’, shrink = 0.1, width = 2)) # width表示箭头宽度plt.text (2, 1, r’$\mu=100$, fontsize = 15)plt.grid(True)plt. annotate(s, xy = arrow_crd, xytext = text_crd, arrowprops = dict)</code></pre><h2 id="使用Matplotlib创建散点图"><a href="#使用Matplotlib创建散点图" class="headerlink" title="使用Matplotlib创建散点图"></a>使用Matplotlib创建散点图</h2><pre><code class="python">&gt;&gt;&gt; import matplotlib&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; fig = plt.figure()&gt;&gt;&gt; ax=fig.add_subplot(111)&gt;&gt;&gt;ax.scatter(datingDataMat[:,1],datingDataMat[:,2])&lt;matplotlib.collections.PathCollection object at 0x00000271B608B460&gt;&gt;&gt;&gt; plt.show()</code></pre><p>figure语法说明</p><p>figure(num&#x3D;None, figsize&#x3D;None, dpi&#x3D;None, facecolor&#x3D;None, edgecolor&#x3D;None, frameon&#x3D;True)</p><p>num:图像编号或名称，数字为编号 ，字符串为名称</p><p>figsize:指定figure的宽和高，单位为英寸；</p><p>dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80 1英寸等于2.5cm,A4纸是 21*30cm的纸张</p><p>facecolor:背景颜色</p><p>edgecolor:边框颜色</p><p>frameon:是否显示边框</p><p>add_subplot(3, 2, 1) # 推荐此种写法</p><p>add_subplot(321)</p><table><thead><tr><th>(3,2,1)</th><th>(3,2,2)</th></tr></thead><tbody><tr><td>(3,2,3)</td><td>(3,2,4)</td></tr><tr><td>(3,2,5)</td><td>(3,2,6)</td></tr></tbody></table><pre><code class="python">ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*array(datingLabels),15.0*array(datingLabels))#https://blog.csdn.net/weixin_30364325/article/details/96601143#scatter（x,y,s=1,c=&quot;g&quot;,marker=&quot;s&quot;,linewidths=0）#s:散列点的大小,c:散列点的颜色，marker：形状，linewidths：边框宽度</code></pre><h1 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h1><p>简单的说，K-近邻算法采用测量不同特征值之间的距离方法进行分类。</p><p>K-近邻算法</p><p>优点：精度高、对异常值不敏感、无数据输入假定</p><p>缺点：计算复杂度高、空间复杂度高</p><p>适用数据范围：数值型和标称型</p><h2 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h2><p>存在一个样本数据集合,也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后,将新数据的每个特征与样本集中数据对应的特征进行比较,然后算法提取样本集中特征最相似数据(最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据,这就是k-近邻算法中k的出处,通常k是不大于20的整数。最后,选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p><h2 id="K-近邻算法的一般流程"><a href="#K-近邻算法的一般流程" class="headerlink" title="K-近邻算法的一般流程"></a>K-近邻算法的一般流程</h2><p>k-近邻算法的一般流程<br>(1)收集数据:可以使用任何方法。</p><p>(2)准备数据:距离计算所需要的数值，最好是结构化的数据格式。T(3)分析数据:可以使用任何方法。</p><p>(4)训练算法:此步骤不适用于k-近邻算法。</p><p>(5)测试算法:计算错误率。</p><p>(6)使用算法:首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。</p><h2 id="数据准备：归一化数值"><a href="#数据准备：归一化数值" class="headerlink" title="数据准备：归一化数值"></a>数据准备：归一化数值</h2><pre><code class="python">def autoNorm(dataSet):    minVals = dataSet.min(0)    maxVals = dataSet.max(0)#参数0使得函数可以从列选取最大最小值，而不是选取当前行的最大最小值    ranges = maxVals - minVals    normDataSet = np.zeros(np.shape(dataSet))    #shape：查看矩阵或者数组的维数    #创建一个和dataSet一样维度的数组    m = dataSet.shape[0]    #返回第一维的长度    normDataSet = dataSet - np.tile(minVals, (m, 1))    normDataSet = normDataSet/np.tile(ranges, (m, 1))   #特征矩阵有1000*3个值，而minVals，range的值为1*3.为解决这个问题我们使用Numpy中tile()函数将变量内容复制成输入矩阵同等大小的矩阵    return normDataSet, ranges, minVals</code></pre><p>在处理不同取值范围的特征值时，我们通常采用的方法是将数值归一化如将数值处理为0到1 或-1到1之间，下面的公式可以将任意取值范围的特征值转化为0到1区间内的值：</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210804151905615.png" class title="image-20210804151905615"><p>min和max为数据集中最小特征值和最大特征值</p><h2 id="分类器针对网站的测试代码"><a href="#分类器针对网站的测试代码" class="headerlink" title="分类器针对网站的测试代码"></a>分类器针对网站的测试代码</h2><pre><code class="python">def datingClassTest():    hoRatio = 0.10      #10%拿去做测试    datingDataMat, datingLabels = file2matrix(&#39;datingTestSet2.txt&#39;)       #从文件加载数据集    normMat, ranges, minVals = autoNorm(datingDataMat) #数据处理-归一化数值    m = normMat.shape[0] #第一维的长度    numTestVecs = int(m*hoRatio)#测试集的个数    errorCount = 0.0 #记录出错的次数    for i in range(numTestVecs):                #0~numTestVecs为测试集 numTestVecs~m为训练集个数        classifierResult=classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],3)        #打印预测结果        print(&quot;the classifier came back with: %d, the real answer is: %d&quot; % (classifierResult, datingLabels[i]))        #判断是否错误        if (classifierResult != datingLabels[i]): errorCount += 1.0            #打印错误率    print(&quot;the total error rate is: %f&quot; % (errorCount / float(numTestVecs)))    print(errorCount)</code></pre><h2 id="预测函数"><a href="#预测函数" class="headerlink" title="预测函数"></a>预测函数</h2><pre><code class="python">def classifyPerson():    resultList = [&#39;not at all&#39;, &#39;in small doses&#39;, &#39;in large doses&#39;] #预测结果    percentTats = float(input(&quot;percentage of time spent playing video games?&quot;))    ffMiles = float(input(&quot;frequent flier miles earned per year?&quot;))    iceCream = float(input(&quot;liters of ice cream consumed per year?&quot;))    datingDataMat, datingLabels = file2matrix(&#39;datingTestSet2.txt&#39;)#导入数据    normMat, ranges, minVals = autoNorm(datingDataMat)    inArr = np.array([ffMiles, percentTats, iceCream, ])#需要预测的数据    classifierResult = classify0((inArr - minVals)/ranges, normMat, datingLabels, 3)    print(&quot;You will probably like this person: %s&quot; % resultList[classifierResult - 1])</code></pre><h1 id="决策树（ID3，C4-5，CART，C5）"><a href="#决策树（ID3，C4-5，CART，C5）" class="headerlink" title="决策树（ID3，C4.5，CART，C5）"></a>决策树（ID3，C4.5，CART，C5）</h1><p><a href="https://blog.csdn.net/c406495762/article/details/75663451?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162090531916780255260545%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162090531916780255260545&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-75663451.nonecase&utm_term=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&spm=1018.2226.3001.4450">https://blog.csdn.net/c406495762/article/details/75663451?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162090531916780255260545%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162090531916780255260545&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-75663451.nonecase&amp;utm_term=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&amp;spm=1018.2226.3001.4450</a></p><p>决策树是什么？决策树(decision tree)是一种基本的分类与回归方法。举个通俗易懂的例子，如下图所示的流程图就是一个决策树，长方形代表判断模块(decision block)，椭圆形成代表终止模块(terminating block)，表示已经得出结论，可以终止运行。从判断模块引出的左右箭头称作为分支(branch)，它可以达到另一个判断模块或者终止模块。我们还可以这样理解，分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边(directed edge)组成。结点有两种类型：内部结点(internal node)和叶结点(leaf node)。内部结点表示一个特征或属性，叶结点表示一个类。蒙圈没？？如下图所示的决策树，长方形和椭圆形都是结点。长方形的结点属于内部结点，椭圆形的结点属于叶结点，从结点引出的左右箭头就是有向边。而最上面的结点就是决策树的根结点(root node)。这样，结点说法就与模块说法对应上了，理解就好。</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/20170721162306492" class title="img"><p>使用决策树做预测需要以下过程：</p><pre><code>收集数据：可以使用任何方法。比如想构建一个相亲系统，我们可以从媒婆那里，或者通过参访相亲对象获取数据。根据他们考虑的因素和最终的选择结果，就可以得到一些供我们利用的数据了。准备数据：收集完的数据，我们要进行整理，将这些所有收集的信息按照一定规则整理出来，并排版，方便我们进行后续处理。分析数据：可以使用任何方法，决策树构造完成之后，我们可以检查决策树图形是否符合预期。训练算法：这个过程也就是构造决策树，同样也可以说是决策树学习，就是构造一个决策树的数据结构。测试算法：使用经验树计算错误率。当错误率达到了可接收范围，这个决策树就可以投放使用了。使用算法：此步骤可以使用适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。</code></pre><h2 id="熵（entropy）："><a href="#熵（entropy）：" class="headerlink" title="熵（entropy）："></a>熵（entropy）：</h2><p>熵（entropy）：表示随机变量的不确定性</p><p>熵定义为信息的期望值 </p><p>xi的信息定义为</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210804151930702.png" class title="image-20210804151930702"><p>熵:</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210804151948585.png" class title="image-20210804151948585"><p><strong>熵越大，随机变量的不确定性越大。</strong></p><p><strong>熵越小，随机变量的不确定性越小。</strong> </p><h2 id="经验熵"><a href="#经验熵" class="headerlink" title="经验熵"></a>经验熵</h2><p>当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck，k &#x3D; 1,2,3,···,K，|Ck|为属于类Ck的样本个数，这经验熵公式可以写为：</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210804152006522.png" class title="image-20210804152006522"><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>在划分数据集之前之后信息发生的改变称为信息增益，获得信息增益最高的特征就是最好的选择。</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210804152018577.png" class title="image-20210804152018577"><p>其中D时训练数据集，A时某个特征</p><p>根据信息增益准则的特征选择方法是：</p><p>1.对训练集（或子集）D，计算其每个特征的信息增益</p><p>2.比较他们的大小，选择信息增益最大的特征</p><h2 id="计算给定数据集的香农熵"><a href="#计算给定数据集的香农熵" class="headerlink" title="计算给定数据集的香农熵"></a><strong>计算给定数据集的香农熵</strong></h2><pre><code class="python">def calcShannonEnt(dataSet):    numEntries = len(dataSet) #返回数据集的行数    labelCounts = &#123;&#125;  #保存每个标签（label）出现次数的字典    for featVec in dataSet: #对每组特征向量进行统计 统计频数        currentLabel = featVec[-1] #提取标签（label）信息        if currentLabel not in labelCounts.keys(): #如果标签（label）没有放入统计次数的字典，添加进去            labelCounts[currentLabel] = 0        labelCounts[currentLabel] += 1       shannonEnt = 0.0  #经验熵（香农熵）    for key in labelCounts: #计算香农熵        prob = float(labelCounts[key])/numEntries #选择该标签（label）的概率        shannonEnt -= prob * log(prob, 2) #log base 2（利用公式计算）    return shannonEnt  #返回经验熵</code></pre><h2 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h2><h3 id="按照给定特征划分数据集"><a href="#按照给定特征划分数据集" class="headerlink" title="按照给定特征划分数据集"></a>按照给定特征划分数据集</h3><pre><code class="python">#按照给定特征划分数据集def splitDataSet(dataSet, axis, value): #待划分的数据集、划分数据集的特征、特征的返回值    retDataSet = []   #创建分会的数据列表    for featVec in dataSet: #遍历数据集        if featVec[axis] == value:            reducedFeatVec = featVec[:axis]     #去掉axis特征            reducedFeatVec.extend(featVec[axis+1:]) #把axis后面的特征添加到列表            retDataSet.append(reducedFeatVec)    return retDataSet</code></pre><p>列表中的extend()和append()</p><pre><code class="python">#extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。#append（）是将你传入的参数看做一个元素，拼到 上一个list中。a=[1, 2, &#39;3&#39;, &#39;1&#39;]a.extend([1,2])print(a)#[1, 2, &#39;3&#39;, &#39;1&#39;, 1, 2]b=[1, 2, &#39;3&#39;, &#39;1&#39;]b.append([1,2])print(b)#[1, 2, &#39;3&#39;, &#39;1&#39;, [1, 2]]</code></pre><h3 id="选择最好的数据集划分方式"><a href="#选择最好的数据集划分方式" class="headerlink" title="选择最好的数据集划分方式"></a>选择最好的数据集划分方式</h3><p>遍历数据集，循环计算香农熵和splitDataSet()函数，找到最好的特征划分方式，熵计算将会告诉我们如何划分数据集事最好的数据组织方式。</p><pre><code class="python">#选择最好的数据集划分方式def chooseBestFeatureToSplit(dataSet):    numFeatures = len(dataSet[0]) - 1      #特征的数量（最后一个为类别所以要减一）    baseEntropy = calcShannonEnt(dataSet)   #计算数据集的熵    bestInfoGain = 0.0 #信息增益变量    bestFeature = -1    #最佳特征    for i in range(numFeatures):        #遍历所有特征        featList = [example[i] for example in dataSet]#获取dataSet的所有第i个特征        uniqueVals = set(featList)       #去除重复的特征（set中元素不可重复）        newEntropy = 0.0  #初始化熵        for value in uniqueVals:   #计算信息增益            subDataSet = splitDataSet(dataSet, i, value) #划分子集            prob = len(subDataSet)/float(len(dataSet)) #计算自己的频率            newEntropy += prob * calcShannonEnt(subDataSet) # 计算熵        infoGain = baseEntropy - newEntropy     #计算信息增益        if (infoGain &gt; bestInfoGain):                   bestInfoGain = infoGain         #更新信息增益为最大的信息增益            bestFeature = i    #记录信息增益最大的特征的索引值    return bestFeature   #返回索引值</code></pre><p><code>featList = [example[i] for example in dataSet]</code>的用法</p><pre><code class="python">&gt;&gt;&gt; dataSet[[1, 1, &#39;yes&#39;], [1, 1, &#39;yes&#39;], [1, 0, &#39;no&#39;], [0, 1, &#39;no&#39;], [0, 1, &#39;no&#39;]]&gt;&gt;&gt; i = 0&gt;&gt;&gt; featList = [example[i] for example in dataSet]&gt;&gt;&gt; featList[1, 1, 1, 0, 0]&gt;&gt;&gt; i = 0&gt;&gt;&gt; classList = [example[-1] for example in dataSet]&gt;&gt;&gt; classList[&#39;yes&#39;, &#39;yes&#39;, &#39;no&#39;, &#39;no&#39;, &#39;no&#39;]</code></pre><p><code>set()</code>用法：set顾名思义是集合，里面不能包含重复的元素，接收一个list作为参数</p><pre><code class="python"> #python set类是在python的sets模块中，大家现在使用的python2.3中，不需要导入sets模块可以直接创建集合。&gt;&gt;&gt;set(&#39;boy&#39;)set([&#39;y&#39;, &#39;b&#39;, &#39;o&#39;])#集合添加、删除#集合的添加有两种常用方法，分别是add和update。#集合add方法：是把要传入的元素做为一个整个添加到集合中，例如：&gt;&gt;&gt; a = set(&#39;boy&#39;)&gt;&gt;&gt; a.add(&#39;python&#39;)&gt;&gt;&gt; aset([&#39;y&#39;, &#39;python&#39;, &#39;b&#39;, &#39;o&#39;])#集合update方法：是把要传入的元素拆分，做为个体传入到集合中，例如：&gt;&gt;&gt; a = set(&#39;boy&#39;)&gt;&gt;&gt; a.update(&#39;python&#39;)&gt;&gt;&gt; aset([&#39;b&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;, &#39;p&#39;, &#39;t&#39;, &#39;y&#39;])#集合删除操作方法：removeset([&#39;y&#39;, &#39;python&#39;, &#39;b&#39;, &#39;o&#39;])&gt;&gt;&gt; a.remove(&#39;python&#39;)&gt;&gt;&gt; aset([&#39;y&#39;, &#39;b&#39;, &#39;o&#39;])</code></pre><h3 id="递归构建决策树"><a href="#递归构建决策树" class="headerlink" title="递归构建决策树"></a>递归构建决策树</h3><p>工作原理：得到原始数据集，然后基于最好的属性值划分数据集，有趣特征可能多余两个，因此可能存在大于两个支点的数据集划分。第一次划分之后，数据将被向下传递到树分支点的下一个节点，在这个节点上，我们可以再次划分数据。因此我们可以采用递归的原理处理数据。</p><p>递归结束的条件是：程序遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果所有实例具有相同的分类，则得到的一个叶子节点或者终止块。任何到达叶子节点的数据必然属于叶子节点的分类。如下图所示。</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210804200335848.png" class title="image-20210804200335848"><p>majorityCnt函数的作用，就是找出classList这堆标签里，出现次数最多的哪个标签。</p><p>classCount是个字典，记录每个标签出现的次数。</p><p><a href="http://www.cnblogs.com/65702708/archive/2010/09/14/1826362.html">sorted函数</a>把classCount按照键值对的值进行降序排序，返回一个tuple的list。sortedClassCount[0][0]就是出现次数最多的那个标签了。</p><pre><code class="python">import operator def majorityCnt(classList):#投票表决法    classCount=&#123;&#125;    for vote in classList:        if vote not in classCount.keys(): classCount[vote] = 0        classCount[vote] += 1    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)    return sortedClassCount[0][0] #返回次数最多的标签</code></pre><h2 id="创建树的函数代码"><a href="#创建树的函数代码" class="headerlink" title="创建树的函数代码"></a>创建树的函数代码</h2><pre><code class="python">def createTree(dataSet, labels):    classList = [example[-1] for example in dataSet]   #当前数据集的所有标签    if classList.count(classList[0]) == len(classList): #计算有几个标签和第一个标签是一样的，如果个数和总个数相等，所有标签就一样        return classList[0]   # 如果数据集的所有标签（类别） 都相同，则不需要划分    if len(dataSet[0]) == 1: #如果当前数据集一个特征都不剩了，那就不用再划分下去了        return majorityCnt(classList)    bestFeat = chooseBestFeatureToSplit(dataSet) #选出用于划分的最佳属性    bestFeatLabel = labels[bestFeat]  #最佳属性的属性名称    myTree = &#123;bestFeatLabel:&#123;&#125;&#125; #字典：记录最佳属性对应的标签种类、出现次数情况    del(labels[bestFeat])#在属性名称列表中剔除最佳属性    featValues = [example[bestFeat] for example in dataSet]#当前数据集中最佳属性的所有属性值    uniqueVals = set(featValues)#最佳属性的不同属性值     for value in uniqueVals:        subLabels = labels[:]       #复制所有的标签，这样树就不会破坏现有的          # 构建最佳属性的值为value的子树          myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)    return myTree</code></pre><h2 id="测试算法：使用决策树执行分类"><a href="#测试算法：使用决策树执行分类" class="headerlink" title="测试算法：使用决策树执行分类"></a>测试算法：使用决策树执行分类</h2><pre><code class="python">def classify(inputTree, featLabels, testVec):    firstStr = list(inputTree)[0] #获取决策树节点（当前树的根节点的特征名称）    secondDict = inputTree[firstStr] #根节点的所有子节点    featIndex = featLabels.index(firstStr)#找到根节点特征对应的下标     key = testVec[featIndex]#找出待测数据的特征值      valueOfFeat = secondDict[key]#拿这个特征值在根节点的子节点中查找，看它是不是叶节点    if isinstance(valueOfFeat, dict):#如果不是叶节点        classLabel = classify(valueOfFeat, featLabels, testVec) #递归地进入下一层节点    else: classLabel = valueOfFeat#如果是叶节点：确定待测数据的分类     return classLabel</code></pre><h2 id="决策树的可视化"><a href="#决策树的可视化" class="headerlink" title="决策树的可视化"></a>决策树的可视化</h2><h3 id="在Python中使用Matplotlib注解绘制树形图"><a href="#在Python中使用Matplotlib注解绘制树形图" class="headerlink" title="在Python中使用Matplotlib注解绘制树形图"></a>在Python中使用Matplotlib注解绘制树形图</h3><h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>基于概率论的分类方法。</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210815160640647.png" class title="image-20210815160640647"><p><strong>朴素贝叶斯</strong></p><p>优点：在数据少的情况下仍然有效</p><p>缺点：对于输入数据的准备方式较为敏感</p><p>适用数据类型：标称型数据</p><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210809161610428.png" class title="image-20210809161610428"><p>已知p(x|c)求p(c|x)   （贝叶斯准则，交换条件概率中的条件和结果）</p><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210809162911242.png" class title="image-20210809162911242"><h2 id="使用条件概率来分类"><a href="#使用条件概率来分类" class="headerlink" title="使用条件概率来分类"></a>使用条件概率来分类</h2><p>贝叶斯决策理论要求计算两个概率p1(x,y)和p2(x,y):</p><ul><li>如果p1(x,y)&gt;p2(x,y),那么属于类别1</li><li>如果p2(x,y)&gt;p1(x,y),那么属于类别2</li></ul><p>但是这两个准则并不是贝叶斯决策的所有内容。</p><p>用p1、p2只是为了尽可能简化描述，而真正需要计算和比较的是p(c1|x,y)和p(c2|x,y)</p><p>可以定义贝叶斯分类准则为：</p><ul><li>如果p(c1|x,y)&gt;p(c2|x,y)，那么属于类别1</li><li>如果p(c1|x,y)&gt;p(c2|x,y)，那么属于类别2</li></ul><h2 id="使用Python进行文本分类"><a href="#使用Python进行文本分类" class="headerlink" title="使用Python进行文本分类"></a>使用Python进行文本分类</h2><h3 id="准备数据：从文本中构建词向量"><a href="#准备数据：从文本中构建词向量" class="headerlink" title="准备数据：从文本中构建词向量"></a>准备数据：从文本中构建词向量</h3><h4 id="词表到向量的转换函数"><a href="#词表到向量的转换函数" class="headerlink" title="词表到向量的转换函数"></a>词表到向量的转换函数</h4><pre><code class="python">def loadDataSet():    postingList = [[&#39;my&#39;, &#39;dog&#39;, &#39;has&#39;, &#39;flea&#39;, &#39;problems&#39;, &#39;help&#39;, &#39;please&#39;],                   [&#39;maybe&#39;, &#39;not&#39;, &#39;take&#39;, &#39;him&#39;, &#39;to&#39;, &#39;dog&#39;, &#39;park&#39;, &#39;stupid&#39;],                   [&#39;my&#39;, &#39;dalmation&#39;, &#39;is&#39;, &#39;so&#39;, &#39;cute&#39;, &#39;I&#39;, &#39;love&#39;, &#39;him&#39;],                   [&#39;stop&#39;, &#39;posting&#39;, &#39;stupid&#39;, &#39;worthless&#39;, &#39;garbage&#39;],                   [&#39;mr&#39;, &#39;licks&#39;, &#39;ate&#39;, &#39;my&#39;, &#39;steak&#39;, &#39;how&#39;, &#39;to&#39;, &#39;stop&#39;, &#39;him&#39;],                   [&#39;quit&#39;, &#39;buying&#39;, &#39;worthless&#39;, &#39;dog&#39;, &#39;food&#39;, &#39;stupid&#39;]]    classVec = [0, 1, 0, 1, 0, 1]    #1 代表侮辱性文字, 0 代表正常言论    return postingList, classVecdef createVocabList(dataSet):    vocabSet = set([])  #创建一个空集    for document in dataSet:        vocabSet = vocabSet | set(document) #两个集合的并集    return list(vocabSet)def setOfWords2Vec(vocabList, inputSet):    returnVec = [0]*len(vocabList)   #创建一个其中元素都为0的向量    for word in inputSet:        if word in vocabList:            returnVec[vocabList.index(word)] = 1        else: print(&quot;the word: %s is not in my Vocabulary!&quot; % word)    return returnVec #输出文档向量，每个元素为1或0，fe</code></pre><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><img src="/2021/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/image-20210816110929505.png" class title="image-20210816110929505"><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="1-MNIST"><a href="#1-MNIST" class="headerlink" title="1. MNIST"></a>1. MNIST</h2><p>获取MNIST数据集</p><pre><code class="python">&gt;&gt;&gt; from sklearn.datasets import fetch_openml&gt;&gt;&gt; mnist = fetch_openml(&#39;mnist_784&#39;,version = 1)&gt;&gt;&gt; mnist.keys()dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;frame&#39;, &#39;categories&#39;, &#39;feature_names&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;details&#39;, &#39;url&#39;])</code></pre><p>查看这些数组</p><pre><code class="python">&gt;&gt;&gt; X,y = mnist[&#39;data&#39;],mnist[&#39;target&#39;]&gt;&gt;&gt; X.shape(70000, 784)</code></pre><p>将这些数据使用Matplotlib的imshow()函数将其显示出来</p><pre><code class="python"></code></pre><p>SKLEARN</p><p>参考:</p><ol><li>《机器学习实战》 [美]Peter Harrington</li><li>《机器学习》 周志华</li><li>神经网络15分钟入门 <a href="https://zhuanlan.zhihu.com/p/65472471">https://zhuanlan.zhihu.com/p/65472471</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫笔记-验证码的识别</title>
      <link href="/2021/08/02/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E8%AF%86%E5%88%AB/"/>
      <url>/2021/08/02/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-图片验证码的识别"><a href="#1-图片验证码的识别" class="headerlink" title="1.图片验证码的识别"></a>1.图片验证码的识别</h1><h1 id="2-极验滑动验证码识别"><a href="#2-极验滑动验证码识别" class="headerlink" title="2.极验滑动验证码识别"></a>2.极验滑动验证码识别</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫笔记 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫笔记-基本库的使用-urllib</title>
      <link href="/2021/06/30/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8-urllib/"/>
      <url>/2021/06/30/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8-urllib/</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用urllib"><a href="#1-使用urllib" class="headerlink" title="1.使用urllib"></a>1.使用urllib</h1><p>urllib包含以下4个模块：</p><p><strong>request</strong>：用来模拟发送请求。</p><p><strong>error</strong>：异常处理模块。</p><p><strong>parse</strong>：提供URL处理方法</p><p><strong>robotparser</strong>: 识别网站的robot.txt文件</p><h2 id="1-1-1-发送请求"><a href="#1-1-1-发送请求" class="headerlink" title="1.1.1 发送请求"></a>1.1.1 发送请求</h2><p>使用urllib的request模块</p><h3 id="1-urlopen"><a href="#1-urlopen" class="headerlink" title="1.urlopen()"></a>1.urlopen()</h3><p>抓取整个python官网</p><pre><code class="python">import urllib.requestresponse = urllib.request.urlopen(&#39;https://www.python.org&#39;)print(response.read().decode(&#39;utf-8&#39;))</code></pre><p>利用type()查看输出响应的类型</p><pre><code class="python">print(type(response))#输出结果如下&lt;class &#39;http.client.HTTPResponse&#39;&gt;</code></pre><p>可以看出是一个HTTPResponse类型的对象，主要包含read()、readinto()、getheader(name)、getheaders()、fileno()等方法，以及msg、version、status、reason、debuglevel、closed等属性。</p><p>urlopen中参数的用法：</p><p><strong>data参数</strong></p><p>data参数是可选的，如果添加该参数并且它是字节流编码格式的内容，即bytes类型，需要通过bytes()方法转化。使用data参数时候请求方式为POST请求。</p><pre><code class="python">import urllib.requestimport urllib.parsedata = bytes(urllib.parse.urlencode(&#123;&#39;word&#39;:&#39;hello&#39;&#125;),encoding=&#39;utf8&#39;)response = urllib.request.urlopen(&#39;https://www.httpbin.org/post&#39;,data=data)print(response.read())</code></pre><p>urlencode():将字典转化为字符串。</p><p><strong>timeout参数</strong></p><p>timeout参数用于设置超时时间，单位为秒。</p><pre><code class="python">import urllib.requestresponse = urllib.request.urlopen(&#39;https://www.httpbin.org/get&#39;,timeout=1)print(response.read())</code></pre><p>可以利用try except语句来实现，一个网页请求时间过长就抛弃。</p><p><strong>其他参数</strong></p><p>context：用来指定SSL设置。</p><p>cafile和capath：用来指定CA证书和路径</p><h3 id="2-Requset"><a href="#2-Requset" class="headerlink" title="2.Requset"></a>2.Requset</h3><p>请求中如果想加入Headers等信息，就可以用Request类构造</p><p>Request用法：</p><pre><code class="python">import urllib.requestrequest = urllib.request.Request(&#39;https://python.org&#39;)response = urllib.request.urlopen(request)print(response.read())</code></pre><p>Request构造方法</p><pre><code class="python">urllib.request.Request(url,data=None,headers=&#123;&#125;,origin_req_host=None,unverifiable=False,method=None)#url用于请求的URL，必选，其他参数为可选#data如果要传，必须要bytes（字节流）类型的，如果是字典可以先用urllib.parse模块里的urlencode()编码#header是一个字典 请求头#origin_req_host请求方的host名称或IP地址#unverifiable表示是否无法验证#method请求方法</code></pre><h3 id="3-高级用法"><a href="#3-高级用法" class="headerlink" title="3.高级用法"></a>3.高级用法</h3><p>1.验证（账号密码）</p><pre><code class="python">from urllib.request import HTTPPasswordMgrWithDefaultRealm,HTTPBasicAuthHandler,build_openerfrom urllib.error import URLErrorusername = &quot;username&quot;password = &quot;password&quot;url = &#39;http://localhost:5000&#39;#建立了一个处理验证的Handlerp = HTTPPasswordMgrWithDefaultRealm()p.add_password(None,url,username,password) #添加用户和密码auth_handler = HTTPBasicAuthHandler(p) #实例化对象#创建一个Openeropener = build_opener(auth_handler)try:    result = opener.open(url) #打开链接    html = result.read().decode(&#39;utf-8&#39;)    print(html)except URLError as e:    print(e.reason)</code></pre><p>2.代理（添加代理）</p><pre><code></code></pre><p>参考：</p><ol><li>《Python3网络爬虫实战开发》 崔庆</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫笔记 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建-本地图片上传</title>
      <link href="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
      <url>/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前提"><a href="#1-前提" class="headerlink" title="1.前提"></a>1.前提</h2><p>在md文件中插入图片，将博客上传到服务器后，网站中并不会显示图片。</p><h2 id="2-安装插件"><a href="#2-安装插件" class="headerlink" title="2.安装插件"></a>2.安装插件</h2><p>安装<code>hexo-zngw-asset-image</code>插件</p><pre><code>npm install hexo-zngw-asset-image --save</code></pre><h2 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3. 修改配置"></a>3. 修改配置</h2><p>打开根目录下<code>_config.yml</code>配置文件，修改</p><pre><code class="bash">post_asset_folder: true</code></pre><p>添加</p><pre><code class="bash">imgroot: /  #如查有第三方图片存储添写，如果用本地用`/`</code></pre><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h2><ul><li>在<code>*.md</code>文件所在的目录下，创建与<code>*.md</code>文件同名的文件夹。如 在<code>hello-world.md</code>文件新建<code>hello-world</code>目录</li><li>然后将需要的图片放到<code>hello-world</code>目录中</li><li>引用的时候使用<code>[图片上传失败...(image-3a8964-1581251871499)]</code></li></ul><h2 id="5-Typora-MarkDown编辑使用"><a href="#5-Typora-MarkDown编辑使用" class="headerlink" title="5. Typora MarkDown编辑使用"></a>5. Typora MarkDown编辑使用</h2><p>用Typora编辑文件时，可以调整一下图片插入配置，直接拖入本地图片或远程图片自动直接保存为<code>*.md</code>同名文件夹目录</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/image-20210628174601123.png" class title="image-20210628174601123"><p><strong>参考：</strong><br>链接：<a href="https://www.jianshu.com/p/53caddb9f857">https://www.jianshu.com/p/53caddb9f857</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> BLOG </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10+阿里云服务器+HEXO 搭建个人博客</title>
      <link href="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、搭建步骤"><a href="#一、搭建步骤" class="headerlink" title="一、搭建步骤"></a>一、搭建步骤</h2><h3 id="1、在本地计算机安装Hexo环境"><a href="#1、在本地计算机安装Hexo环境" class="headerlink" title="1、在本地计算机安装Hexo环境"></a>1、<strong>在本地计算机安装Hexo环境</strong></h3><h4 id="1-1-安装Node-js"><a href="#1-1-安装Node-js" class="headerlink" title="1.1 安装Node.js"></a>1.1 安装Node.js</h4><p>官网：<a href="https://nodejs.org/en/download/">nodejs.org&#x2F;en&#x2F;download&#x2F;</a></p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626111553982.png" class title="image-20210626111553982"><p>选择LTS（长期支持版 Long Term Support schedule）默认安装就可以</p><p>默认安装就可以，官网有些慢，可以选择其他来源，注意别踩雷。</p><p>安装完成后打开win+R打开cmd，输入node -v 显示版本号则说明安装成功</p><pre><code class="text">C:\Users\ASUS&gt;node -vv12.14.1</code></pre><p>Node.js中自带了npm包管理工具，在cmd中查看npm版本。</p><pre><code class="text">C:\Users\ASUS&gt;npm -v6.13.4</code></pre><p>我们是借助npm来安装Hexo，但是国内镜像源的速度很慢，所以在使用前利用npm安装一个cnpm（淘宝的源）。</p><pre><code class="text">npm install -g cnpm --registry=http://registry.npm.taobao.org</code></pre><p>安装结束后 cnpm -v 来查看版本号</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626111937271.png" class title="image-20210626111937271"><h4 id="1-2-安装Hexo"><a href="#1-2-安装Hexo" class="headerlink" title="1.2 安装Hexo"></a>1.2 安装Hexo</h4><p>在D盘（或任意盘）新建一个blog文件夹用来存放个人博客，使用cmd命令进入该文件夹（不会进入，自行百度）</p><pre><code class="text">D:\blog&gt;cnpm install -g hexo-cli</code></pre><p>cmd输入hexo -v 有版本好说明安装成功</p><p>Hexo安装完成后，在blog文件夹下新建myblogs项目，并对其进行初始化。</p><pre><code class="text">D:\blog&gt;hexo init myblogsD:\blog&gt;cd myblogsD:\blog\myblogs&gt;npm install</code></pre><p>此时，会在blog文件夹下新建myblogs文件夹，并在其内部生成相应的项目文件。</p><p>在myblogs文件夹下启动hexo服务。</p><pre><code class="text">D:\blog\myblogs&gt;hexo server</code></pre><p>若初始化错误，提示没有server命令。输入以下命令，然后重新初始化</p><pre><code class="text">D:\blog\myblogs&gt;npm install hexo-server --save</code></pre><p>此时，通过 <a href="http://localhost:4000/">http://localhost:4000/</a> 便可访问基于Hexo的个人博客主页了。</p><p>1.3 安装Git</p><p>第一步：先从官网下载最新版本的Git</p><p>官网地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626112956915.png" class title="image-20210626112956915"><p>点击上图中表示的地方进行下载，得到Git-2.17.1.2-64-bit.exe文件。如果你的系统是32位的，可以通过如下方式下载：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113010797.png" class title="image-20210626113010797"><p>第二步：双击下载好的git安装包，弹出提示框，如下图：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113024767.png" class title="image-20210626113024767"><p>第三步： 直接点击“Next”进入下一步，选择安装路径，如下图：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113036418.png" class title="image-20210626113036418"><p>第四步：选择好安装路径后，点击“Next”进入下一步，弹出安装配置窗口，包括git命令行、git图形窗口等，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113046306.png" class title="image-20210626113046306"><p>Additional icons 附加图标<br> On the Desktop 在桌面上<br>Windows Explorer integration  Windows资源管理器集成鼠标右键菜单<br> Git Bash Here<br> Git GUI Here<br>Git LFS (Large File Support)  大文件支持<br>Associate .git* configuration files with the default text editor  将 .git 配置文件与默认文本编辑器相关联<br>Associate .sh files to be run with Bash  将.sh文件关联到Bash运行<br>Use a TrueType font in all console windows  在所有控制台窗口中使用TrueType字体<br>Check daily for Git for Windows updates  每天检查Git是否有Windows更新</p><p>第五步：按照上述默认配置，直接点击“Next”进入下一步，弹出“选择开始菜单文件夹”的窗口，如下图所示：<img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113105766.png" class title="image-20210626113105766"></p><p>第六步：按照默认路径即可，直接点击“Next”，进入下一步，进入“选择Git使用的默认编辑器”窗口，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113119727.png" class title="image-20210626113119727"><p>Use the Nano editor by default  默认使用 Nano 编辑器<br>Use Vim (The ubiquitous text editor) as Git’s default editor  使用 Vim 作为 Git 的默认编辑器<br>Use Notepad++ as Git’s default editor  使用 Notepad++ 作为 Git 的默认编辑器<br>Use Visual Studio Code as Git’s default editor  使用 Visual Studio Code 作为Git 的默认编辑器<br>Use Visual Studio Code Insiders as Git’s default editor  使用Visual Studio Code Insiders 作为 Git 的默认编辑器</p><p>第七步：点击“Next”，进入下一步，进入“调整Path环境变量”窗口，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113131427.png" class title="image-20210626113131427"><p>配置PATH环境<br>Use Git from Git Bash only<br>This is the safest choice as your PATH will not be modified at all.You will only be able to use the Git command line tools form Git Bash.<br>这是最安全的选择，因为您的PATH根本不会被修改。您只能使用 Git Bash 的 Git 命令行工具。</p><p>Use Git from the Windows Command Prompt<br>This option is considered safe as it only adds some minimal Git wrappers to your PATH to avoid cluttering your environment with optional Unix tools . You will be able to use Git from both Git Bash and the Windows Command Prompt.<br>这个选项被认为是安全的，因为它只向PATH添加一些最小的 Git包，以避免使用可选的Unix工具混淆环境。 您将能够从 Git Bash 和 Windows 命令提示符中使用 Git。</p><p>Use Git and optional Unix tools from the Windows Command Prompt<br>从Windows命令提示符使用Git和可选的Unix工具<br>Both Git and the optional Unix tools will be added to you PATH<br>Git和可选的Unix工具都将添加到您计算机的 PATH 中<br>Warning:This will override Windows tools like “find and sort”.Only use this option if you understand the implications.<br>警告：这将覆盖Windows工具，如 “ find 和 sort ”。只有在了解其含义后才使用此选项。</p><p>第八步：选第二项，然后点击“Next”进入下一步，选择HTTPS传输后端，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113151131.png" class title="image-20210626113151131"><p>Use the OpenSSL library<br>使用 OpenSSL 库<br>Server certificates will be validated using the ca-bundle.crt file.<br>服务器证书将使用ca-bundle.crt文件进行验证。</p><p>Use the native Windows Secure Channel library<br>使用本地 Windows 安全通道库<br>Server certificates will be validated using Windows Certificate Stores.This option also allows you to use your company’s internal Root CA certificates distributed e.g. via Active Directory Domain Services.<br>服务器证书将使用Windows证书存储验证。此选项还允许您使用公司的内部根CA证书，例如， 通过Active Directory Domain Services 。</p><p>第九步：选择”Use the OpenSSL library”，点击“Next”进入下一步，配置行结束符，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113208626.png" class title="image-20210626113208626"><p>Checkout Windows-style,commit Unix-style line endings<br>Git will convert LF to CRLF when checking out text files.When committing text files,CRLF will be converted to LF .For cross-pltform projects,this is the recommended setting on Windows (“core.autocrlf” is set to “true”)<br>在检出文本文件时，Git会将LF转换为CRLF。当提交文本文件时，CRLF将转换为LF。 对于跨平台项目，这是Windows上推荐的设置（“core.autocrlf”设置为“true”）</p><p>Checkout as-is , commit Unix-style line endings<br>Git will not perform any conversion when checking out text files. When committing text files, CRLF will be converted to LF. For cross-platform projects,this is the recommended setting on Unix (“core.autocrlf” is set to “input”)<br>在检出文本文件时，Git不会执行任何转换。 提交文本文件时，CRLF将转换为LF。 对于跨平台项目，这是Unix上的推荐设置 （“core.autocrlf”设置为“input”）</p><p>Checkout as-is,commit as-is<br>Git will not perform any conversions when checking out or committing text files.Choosing this option is not recommended for cross-platform projects (“core.autocrlf”is set to “false”)<br>在检出或提交文本文件时，Git不会执行任何转换。对于跨平台项目，不推荐使用此选项（“core.autocrlf”设置为“false”）</p><p>第十步：选择第一项，点击“Next”进入下一步，配置终端模拟器，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113221106.png" class title="image-20210626113221106"><p>Use MinTTY (the default terminal of MSYS2)<br>Git Bash will use MinTTY as terminal emulator,which sports a resizable window,non-rectangular selections and a Unicode font. Windows console programs (such as interactive Python) must be launched via ‘winpty’ to work in MinTTY.<br>Git Bash将使用MinTTY作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选区和Unicode字体。 Windows控制台程序（如交互式Python）必须通过’winpty’启动才能在MinTTY中运行。</p><p>Use Windows’ default console window<br>Git will use the default console window of Windows (“cmd.exe”),which works well with Win32 console programs such as interactive Python or node.js , but has a very limited default scroll-back,needs to be configured to use aUnicode font in order to display non-ASCII characters correctly,and prior to Windows 10 its windows was not freely resizable and it only allowed rectangular text selections.<br>Git将使用Windows的默认控制台窗口（“cmd.exe”），该窗口可以与Win32控制台程序（如交互式Python或node.js）一起使用，但默认的回滚非常有限，需要配置为使用unicode 字体以正确显示非ASCII字符，并且在Windows 10之前，其窗口不能自由调整大小，并且只允许矩形文本选择。</p><p>第十一步：选择第一项，直接点击“Next”进入下一步，配置额外选项，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113233312.png" class title="image-20210626113233312"><p>Enable file system caching<br>启用文件系统缓存<br>File system data will be read in bulk and cached in memory for certain operations (“core.fscache” is set to “true”). This provides a significant performance boost.<br>文件系统数据将被批量读取并缓存在内存中用于某些操作（“core.fscache”设置为“true”）。 这提供了显着的性能提升。</p><p>Enable Git Credential Manager<br>启用Git凭证管理器<br>The Git Credential Manager for Windows provides secure Git credential storage for Windows,most notably multi-factor authentication support for Visual Studio Team Services and GitHub. (requires .NET framework v4.5.1 or or later).<br>Windows的Git凭证管理器为Windows提供安全的Git凭证存储，最显着的是对Visual Studio Team Services和GitHub的多因素身份验证支持。 （需要.NET Framework v4.5.1或更高版本）。</p><p>Enable symbolic links<br>启用符号链接<br>Enable symbolic links (requires the SeCreateSymbolicLink permission).Please note that existing repositories are unaffected by this setting.<br>启用符号链接（需要SeCreateSymbolicLink权限）。请注意，现有存储库不受此设置的影响。</p><p>第十二步：使用默认配置，直接点击“Install”开始安装，如下图所示：</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113244577.png" class title="image-20210626113244577"><p>第十三步：安装完成</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626113254649.png" class title="image-20210626113254649"><p>原文链接：<a href="https://blog.csdn.net/qq_32786873/article/details/80570783">https://blog.csdn.net/qq_32786873/article/details/80570783</a></p><h3 id="2、服务端准备工作"><a href="#2、服务端准备工作" class="headerlink" title="2、服务端准备工作"></a>2、服务端准备工作</h3><h4 id="2-1-域名注册"><a href="#2-1-域名注册" class="headerlink" title="2.1 域名注册"></a><strong>2.1 域名注册</strong></h4><p>阿里云域名注册官网上直接注册购买。</p><h4 id="2-2-域名实名认证"><a href="#2-2-域名实名认证" class="headerlink" title="2.2 域名实名认证"></a><strong>2.2 域名实名认证</strong></h4><p>域名注册过程中，必须进行邮箱和身份证实名认证才可以继续购买，我们只需按提示进行操作即可。</p><h4 id="2-3-购买阿里云ECS服务器"><a href="#2-3-购买阿里云ECS服务器" class="headerlink" title="2.3 购买阿里云ECS服务器"></a><strong>2.3 购买阿里云ECS服务器</strong></h4><p>阿里的云服务产品有很多种，如阿里云主机、ECS服务器等。我这里购买的是阿里云ECS服务器。所谓ECS，即弹性计算服务。</p><p>最近百度云高校大学生活动可以免费撸六个月的ECS服务器（2 vCPU 4 GiB(I&#x2F;O优化) ），真香。</p><h4 id="2-4-ECS服务器备案"><a href="#2-4-ECS服务器备案" class="headerlink" title="2.4 ECS服务器备案"></a><strong>2.4 ECS服务器备案</strong></h4><p>备案需要有服务器和域名。</p><p>国家法律规定，使用中国大陆境内服务器托管你的网站时，你必须对你的网站进行备案申请。当你使用阿里云中国大陆境内节点的服务器时，你可以直接在阿里云备案管理系统中提交ICP备案申请。</p><p>ICP备案申请审核通过后，管局（工信部）会给我们一个ICP备案号，我们需要将备案号在网站底部标明。网站在工信部备案成功后，还需要在网站开通之日起30日内登录全国公安机关互联网站安全管理服务平台提交公安联网备案申请。</p><p><a href="https://www.jianshu.com/p/a57bb9ceaf63">https://www.jianshu.com/p/a57bb9ceaf63</a></p><h4 id="2-5-阿里云服务器设置"><a href="#2-5-阿里云服务器设置" class="headerlink" title="2.5 阿里云服务器设置"></a><strong>2.5 阿里云服务器设置</strong></h4><p><strong>（1）重置实例密码</strong></p><p>点击阿里云首页的控制台按钮，登录到云服务器管理控制台，便可以查看自己购买的实例了。</p><p>新买的ECS服务器实例对root用户是没有设置初始密码的,ECS服务器的root密码需要重置才能用。</p><p>重置步骤如下：选中ECS服务器实例，点击下面的重置密码按钮即可重置root用户的密码，密码在实例重启后生效。（该密码必须是字母、数字和其它字符组成的8位以上字符串。）</p><p><strong>（2）远程连接Linux实例</strong></p><p>远程连接服务器的方法都很多。我们既可以通过阿里云自带的VNC（Virtual Network Console，虚拟网络控制台）远程连接Linux实例，也可以通过远程连接软件（例如PuTTY、Xshell、SecureCRT等）连接Linux实例。</p><p>需要说明的是：使用阿里云自带的VNC远程连接Linux实例，登录VNC窗口时还要输入一个6位数的远程连接密码，用于连接ECS管理控制台的管理终端，注意不要与root密码混淆。如果使用VNC这个密码一定要记住。</p><p>具体连接步骤如下：</p><p>a. 在实例列表中选中当前实例，点击右侧按钮：远程连-&gt;VNC。</p><p>b. 输入远程连接密码。</p><p>c. 在控制台中输入用户名：root，及其root密码（实例密码）。回车即可进入阿里云ECS服务器的后台。</p><h4 id="3）配置安全组"><a href="#3）配置安全组" class="headerlink" title="3）配置安全组"></a><strong>3）配置安全组</strong></h4><p>由于我们要通过80端口访问nginx服务，而阿里云默认是禁止80端口访问权限的，所以我们要为实例手动添加安全组，让阿里云给相应的端口和IP放行。该步骤非常重要，若不手动配置，我们将无法通过“公网IP+端口”的方式访问我们的ECS服务器。</p><p>具体操作步骤如下：</p><p>a. 打开阿里云服务管理控制台，点击左侧菜单中的“安全组”按钮，查看安全组列表。</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626114828056.png" class title="image-20210626114828056"><p>b. 点击右上角的“创建安全组”按钮，创建一个新的安全组。</p><p>c. 立即为新建的安全组添加安全组规则，在入方向解除端口和IP限制，具体参数设置如下图所示。这里建议切换到旧版本进行操作.</p><h3 id="3、Hexo博客的阿里云部署"><a href="#3、Hexo博客的阿里云部署" class="headerlink" title="3、Hexo博客的阿里云部署"></a><strong>3、Hexo博客的阿里云部署</strong></h3><p>该步骤是整个博客搭建过程中最重要的一步，实现过程中一定要注意是在服务端操作还是在本地计算机上操作。若在服务器上操作，还要注意是使用root用户进行操作还是使用git用户进行操作。</p><h4 id="3-1-安装nginx"><a href="#3-1-安装nginx" class="headerlink" title="3.1 安装nginx"></a><strong>3.1 安装nginx</strong></h4><p>因为我们用nginx作Web服务器，所以我们需要先安装nginx服务。具体步骤如下：</p><p>使用root用户远程登录阿里云服务器，使用yum命令进行安装。</p><p>a. 安装nginx依赖环境，安装期间有提示一律选yes。</p><pre><code class="text">#yum install gcc-c++#yum install -y pcre pcre-devel#yum install -y zlib zlib-devel#yum install -y openssl openssl-devel</code></pre><p>b. 下载nginx安装包。(下面的链接可以换成官网的最新版本）</p><pre><code class="text">#wget -c http://nginx.org/download/nginx-1.18.0.tar.gz</code></pre><p>c.将安装包解压到&#x2F;usr&#x2F;local目录下。</p><pre><code class="text">#tar -zxvf nginx-1.18.0.tar.gz -C /usr/local</code></pre><p>d. 进入&#x2F;usr&#x2F;local目录，确认nginx解压到该目录下。</p><pre><code class="text">#cd /usr/local#ls</code></pre><p>ls命令会显示该目录下所有文件，你可以在任意位置查看当前目录下所有的文件。</p><p>e. 进入nginx-1.18.0目录，会发现该目录下有一个configure文件，执行该配置文件。</p><pre><code class="text">#cd nginx-1.18.0/#ls#./configure</code></pre><p>f. 编译并安装nginx。</p><pre><code class="text">#make#make install</code></pre><p>如果编译出现错误，自行百度。</p><p>g. 查找nginx安装目录。</p><pre><code class="text">#whereis nginx</code></pre><p>h.进入安装目录。</p><pre><code class="text">#cd /usr/local/nginx#ls</code></pre><p>i. 由于nginx默认通过80端口访问，而Linux默认情况下不会开发该端口号，因此需要开放linux的80端口供外部访问。</p><pre><code class="text">#/sbin/iptables -I INPUT -p tcp –-dport 80 -j ACCEPT</code></pre><p>j. 进入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin目录，启动nginx。</p><pre><code class="text">#cd sbin#./nginx</code></pre><p>没有任何消息，代表启动成功。此时，便可以通过“公网IP+端口”的方式访问 <a href="https://link.zhihu.com/?target=http://xx.xx.xxx.xxx:80/">http://xx.xx.xxx.xxx:80/</a> 进入nginx欢迎页面了。<strong>注：可以使用.&#x2F;nginx -s stop命令停止服务</strong></p><h4 id="3-2-配置nginx服务器路由"><a href="#3-2-配置nginx服务器路由" class="headerlink" title="3.2 配置nginx服务器路由"></a><strong>3.2 配置nginx服务器路由</strong></h4><p>a. 专门为hexo创建一个部署目录&#x2F;home&#x2F;www&#x2F;hexo。</p><pre><code class="text">#mkdir -p /home/www/hexo</code></pre><p>b. 进入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf目录，打开该文件夹下的nginx.conf配置文件。</p><pre><code class="text">#cd /usr/local/nginx/conf#ls#vim nginx.conf</code></pre><ul><li>进入后按i键由命令模式切换到编辑模式(左下角会显示INSERT）。</li><li>将其中的部署根目录（root）修改为**&#x2F;home&#x2F;www&#x2F;hexo**；</li><li>将域名（server<em>name）修改为你自己的域名（www.</em>__<strong><em>.</em></strong>)，如果暂时没有域名就填阿里云实例的公网ip，以后有了再改回来；</li><li>查看监听端口（listen）的系统默认值是否为80（不用修改）。</li><li>完成以上修改后，先按  <strong>Esc</strong>  由编辑模式切换到命令模式，再输入  <strong>:wq</strong>  命令保存并退出编辑器。</li></ul><h4 id="3-3-安装node-js"><a href="#3-3-安装node-js" class="headerlink" title="3.3 安装node.js"></a><strong>3.3 安装node.js</strong></h4><p>a. 退回根目录，安装node.js。</p><pre><code class="text">#cd ~#curl -sL https://rpm.nodesource.com/setup_10.x | bash -#yum install -y nodejs</code></pre><p>b. 查看安装结果，打印版本号即为安装成功。</p><pre><code class="text">#node -v#npm -v</code></pre><h4 id="3-4-安装Git"><a href="#3-4-安装Git" class="headerlink" title="3.4 安装Git"></a><strong>3.4 安装Git</strong></h4><p>a. 使用yum命令安装Git，安装期间有提示一律选yes。</p><pre><code class="text">#yum install git</code></pre><p>b. 安装成功后，查看版本号。</p><pre><code class="text">#git --version</code></pre><h4 id="3-5-创建git用户"><a href="#3-5-创建git用户" class="headerlink" title="3.5 创建git用户"></a><strong>3.5 创建git用户</strong></h4><p>为了实现博客的自动部署，我们后面要使用公钥免密登录服务器。为了安全起见，最好不要使用root用户免密登录。因此，我们要创建一个新的git用户，用于远程公钥免密登录服务器。</p><p>a. 创建git用户。</p><pre><code class="text">#adduser git</code></pre><p>b. 修改git用户的权限。</p><pre><code class="text">#chmod 740 /etc/sudoers</code></pre><p>c. 打开文件。</p><pre><code class="text">#vim /etc/sudoers</code></pre><p>进入后按i键由命令模式切换到编辑模式。找到 root ALL&#x3D;(ALL) ALL，在下面添加一行 <strong>git ALL&#x3D;(ALL) ALL（注意和上面的命令对齐（TAB键））</strong>。修改完成后，先按 <strong>Esc</strong> 由编辑模式切换到命令模式，再输入 <strong>:wq</strong> 命令保存并退出编辑器。</p><p>d. 保存退出后改回权限。</p><pre><code class="text">#chmod 400 /etc/sudoers</code></pre><p>e. 设置git用户的密码。</p><pre><code class="text">#sudo passwd git</code></pre><p>设置密码：****，这样我们就可以使用git用户远程登录阿里云服务器了。</p><h4 id="3-6-给git用户配置ssh免密公钥登录"><a href="#3-6-给git用户配置ssh免密公钥登录" class="headerlink" title="3.6 给git用户配置ssh免密公钥登录"></a><strong>3.6 给git用户配置ssh免密公钥登录</strong></h4><p>使用git用户免密公钥登录阿里云服务器的原理是：在本地计算机生成一个公钥文件和一个秘钥文件（类似于一个钥匙配一把锁)，然后使用FTP工具将公钥文件上传到阿里云服务器，并将公钥安装到authorized_keys列表中去（即：将公钥文件的内容拷贝到authorized_keys文件中去）。这样本地计算机便可以通过ssh方式免密连接我们的阿里云服务器了。</p><p>a. 在服务器端将登陆用户切换到git用户，然后在~目录(根目录)下创建.ssh文件夹，用来存放公钥。</p><pre><code class="text">#su git$cd ~$mkdir .ssh</code></pre><p>b. 在本地计算机桌面右键打开GitBash，在本地生成公钥&#x2F;私钥对。</p><pre><code class="text">$cd ~$cd .ssh$ssh-keygen</code></pre><p>接下来，碰见系统询问就直接按回车键。此时便会在本地计算机的用户根目录（C:\Users\ASUS）下自动生成.ssh（隐藏）文件夹，并在其中创建两个文件，分别为：id_rsa（私钥）和id_rsa.pub（公钥）。</p><p>c. 在本地计算机上给私钥设置权限。</p><pre><code class="text">$ chmod 700 ~/.ssh$ chmod 600 ~/.ssh/id_rsa</code></pre><p>d. 下载并安装FTP工具，这里推荐阿里云官方提供的FileZilla</p><p>e. 打开FileZilla，使用git用户通过22端口远程连接到阿里云服务器，将客服端生成的公钥上传到服务器的~&#x2F;.ssh目录下。</p><p>主机：你的服务器公网ip</p><p>用户名：git</p><p>密码：自己设定的</p><p>端口：22</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210626133855290.png" class title="image-20210626133855290"><p>f. 上传完成后切回服务器端，继续以git用户的身份进入服务器~&#x2F;.ssh目录，新建一个authorized_keys文件，并将id_rsa.pub文件中公钥的内容拷贝到该文件中。<strong>（注：该步骤既可以用命令行操作，也可使用FTP工具操作。）</strong></p><pre><code class="text">$cd ~/.ssh$cp id_rsa.pub authorized_keys$cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre><p>g. 在服务器上设置文件权限：</p><pre><code class="text">$chmod 600 ~/.ssh/authorized_keys$chmod 700 ~/.ssh</code></pre><p>h. 确保设置了正确的SELinux上下文。</p><pre><code class="text">$ restorecon -Rv ~/.ssh</code></pre><p>现在，当您使用ssh远程登录服务器时，将不会提示您输入密码（除非您在创建密钥对时输入了密码）。(报错解决：<a href="https://blog.csdn.net/xiaohaolaoda/article/details/105434315">https://blog.csdn.net/xiaohaolaoda/article/details/105434315</a>)</p><p>i. 接下来在本地计算机上使用ssh方式连接我们的云服务器。</p><pre><code class="text">$ssh -v git@xxx.xxx.xxx.xxx（阿里云公网IP）</code></pre><p>或</p><pre><code class="text">$ssh git@xxx.xxx.xxx.xxx（阿里云公网IP）</code></pre><p><strong>3.7 配置Git仓库</strong></p><p>a. 在服务器上使用git用户创建一个Git仓库，并且在该仓库中新建一个post-receive钩子文件。</p><pre><code class="text">$cd ~$git init --bare hexo.git$vi ~/hexo.git/hooks/post-receive</code></pre><p>b. 进入后按i键由命令模式切换到编辑模式。输入： <strong>git –work-tree&#x3D;&#x2F;home&#x2F;www&#x2F;hexo –git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;hexo.git checkout -f</strong></p><p>即：让钩子文件删除&#x2F;home&#x2F;www&#x2F;hexo目录下原有的文件，然后从blog.git仓库 clone 新的博客静态文件到&#x2F;home&#x2F;www&#x2F;hexo目录下。</p><p>完成以上修改后，先按 <strong>Esc</strong> 由编辑模式切换到命令模式，再输入 <strong>:wq</strong> 命令保存并退出编辑器。</p><p>c. 授予钩子文件可执行权限。</p><pre><code class="text">$chmod +x ~/hexo.git/hooks/post-receive$cd ~$sudo chmod -R 777 /home/www/hexo</code></pre><p>d. 重启ECS服务器实例。</p><p>至此我们就完成了所有关于服务器端的配置。</p><h3 id="4、其它配置"><a href="#4、其它配置" class="headerlink" title="4、其它配置"></a><strong>4、其它配置</strong></h3><h4 id="4-1-客服端hexo配置"><a href="#4-1-客服端hexo配置" class="headerlink" title="4.1 客服端hexo配置"></a><strong>4.1 客服端hexo配置</strong></h4><p>a. 在本地计算机hexo的工程目录(myblogs)下，找到_config.yml，对deploy参数进行修改，如下图所示。马赛克是你的服务器公网ip。</p><img src="/2021/06/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/v2-c0b29c68a9b319f1bbdc5ebcea9ea8d4_1440w.jpg" class title="img"><p>b. 在本地计算机安装插件: hexo-deployer-git 和 hexo-server。在myblogs文件夹下右键打开GitBash，输入以下命令：</p><pre><code class="text">$npm install hexo-deployer-git --save$npm install hexo-server</code></pre><p>c. 在本地计算机配置Git全局变量。输入以下命令：</p><pre><code class="text">$ git config --global user.email &quot;xxxxxxxxxx@qq.com&quot;$ git config --global user.name “qimu”</code></pre><p>d. 使用Hexo生成、发布个人博客。</p><pre><code class="text">$ hexo clean$ hexo generate$ hexo deploy</code></pre><p>此时，便可以通过浏览器访问<a href="https://link.zhihu.com/?target=http://xxx.xxx.xxx.xxx:80/">http://xxx.xxx.xxx.xxx:80/</a> 进入hexo我的博客主页了。</p><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/137022058">https://zhuanlan.zhihu.com/p/137022058</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> BLOG </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
